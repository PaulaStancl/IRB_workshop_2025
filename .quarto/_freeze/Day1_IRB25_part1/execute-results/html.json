{
  "hash": "e0ba86c8b6826f2a9c0c96e55bc29a49",
  "result": {
    "markdown": "---\ntitle: \"Introduction to R\"\nauthor: \n  - name: \"dr.sc. Paula Štancl\"\n    affiliation: \"Kuzman Consulting d.o.o\"\n  - name: \"dr.sc. Andrea Gelemanović\"\n    affiliation: \"MedILS, UNIST\"\nformat:\n  html:\n    self-contained: true\n    toc: true\n    toc-depth: 5\n    code-fold: false\n    fig-align: center\n    df-print: paged\n    code-summary: \"Show code\"\n    code-line-numbers: false\n    code-tools: true\n    \nexecute:\n  echo: true\n  message: false\n  collapse: true\n---\n\n\nHello everyone to your first session \"Introduction to R\" in the Institute Ruder Boskovic (IRB) workshop. During this session, you will learn the basics to R programming and working environment.\n\n::: callout-tip\n# How to quickly code a chunk\n\n**Ctrl + Alt + I**\n:::\n\n# R as calculator\n\nR can be used as a basic calculator to perform arithmetic operations like addition, subtraction, multiplication, and division.\n\n| Expression        | Description                  | Result |\n|-------------------|------------------------------|--------|\n| `(9 + 2)*(3 - 1)` | Multiply sum and difference  | `22`   |\n| `sqrt(2)^2`       | Square of square root of 2   | `2`    |\n| `5 / 2`           | Division (gives decimal)     | `2.5`  |\n| `5 %/% 2`         | Integer (floor) division     | `2`    |\n| `5 %% 2`          | Remainder (modulo operation) | `1`    |\n\n##### Task\n\nA scientist has **48** stem cells. Each one divides into **2** daughter cells.\n\n-   How many cells will there be after division?\n\n-   How many full groups of **10 cells** can you make after first division? How many left over?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Solve here\n48*2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 96\n```\n:::\n\n```{.r .cell-code}\n(48*2) %/% 10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n\n```{.r .cell-code}\n(48*2) %% 10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n\n# R objects\n\n## Variable\n\n### Creating a variable\n\nTo create a certain object, you need to give it a name followed by the assignment operator **\\<-** and the value you want to store it. To see the stored value in a variable, you can call it using *parentheses* or *by typing the object name*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- 5\n# Print\n#vec\n# Print\n(vec2 <- 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n\n### Naming a variable\n\nWhen naming the variables, they mustn't be too short or too long. Avoid meaningless variable names and name them logically ( example: **`mRNA_human`** ) R is case sensitive ( example: **`vec`** is different to **`Vec`** ). Some names cannot be used because they are the names of fundamental functions in R (e.g., **`if`**, **`else`**, **`for`**...). In general, even if it's allowed, it's best to not use other function names (e.g., **`c`**, **`t`**, **`mean`**, **`data`**, **`df`**). Furthermore, avoid using dots (**`.`**) within a variable name, such as in `my.mRNA`. A lot of functions in R have dots in their name for historical reasons and dots have special meaning in R so it is best to avoid them.\n\n## Functions and useful tricks\n\nFunctions are \"conserved scripts\" that automate more complicated sets of commands including operations assignments, etc. Many functions are predefined, or can be made available by importing R packages (more on that later). A function usually gets one or more inputs called arguments. Functions often (but not always) return a value. Adding `?` in front of any function opens a help, description and usage of the function. A typical example function is `typeof`.\n\n::: callout-tip\n## Help with functions\n\nWhat does the function type do?\n\n(Hint: ?typeof)\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?typeof\n\ntypeof(2)\n```\n:::\n\n\n## Vectors\n\nA vector is the most common and basic data type in R. A vector is composed by a series of values. V ectors can be composed of integer/numeric, logical or character values. Using the **`c()`**function you can assign a series of values to a vector. The simplest way to create a sequence of numbers in R is by using the **`:`** operator.\n\nExamples of defining vectors\n\n\n::: {.cell}\n\n```{.r .cell-code}\n( first_vec_num <- c(1,2,5) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 5\n```\n:::\n\n```{.r .cell-code}\n#The simplest way to create a sequence of numbers in R is by using the : operator. \n( second_vec_num <- 1:30 )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30\n```\n:::\n\n```{.r .cell-code}\n( first_vec_character <- c(\"human\", \"mouse\", \"dog\", \"cat\") )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"human\" \"mouse\" \"dog\"   \"cat\"  \n```\n:::\n\n```{.r .cell-code}\n( first_vec_logic <- c(TRUE, FALSE, TRUE) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\n# create a vector containing different types\n( mix_vec <-c(1, \"sea\", TRUE) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\"    \"sea\"  \"TRUE\"\n```\n:::\n:::\n\n\n### Different types and classes\n\n#### Types\n\n-   character\n\n-   double (for double precision floating point numbers)\n\n-   integer\n\n::: callout-tip\n## **Useful functions for determining types**\n\n-   **`class()`**\\\n    Returns the class of an object (e.g., `\"numeric\"`, `\"character\"`, `\"data.frame\"`), giving a general idea of its structure.\n\n-   **`typeof()`**\\\n    Provides the low-level internal storage type of an object (e.g., `\"double\"`, `\"integer\"`, `\"list\"`), which can be more specific than `class()`.\n\n-   **`is.numeric()`**, **`is.character()`**, **`is.logical()`**, etc.\\\n    Return `TRUE` or `FALSE` depending on whether the object is of the specified type. These are useful for checking expected input types in functions.\n\n-   **`as.numeric()`**, **`as.character()`**, **`as.logical()`**, etc.\\\n    Coerce (convert) an object to the specified type, if possible. These are helpful when transforming data types explicitly.\n\n-   **`str()`**\\\n    Provides a compact, readable summary of the structure of an R object, including its type, dimensions, and content preview.\n:::\n\nWhat are the types of our objects?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# double/numeric\ntypeof(first_vec_num)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\n# character\ntypeof(first_vec_character)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\n# logical\ntypeof(first_vec_logic)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n\n```{.r .cell-code}\n# character\ntypeof(mix_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n::: callout-warning\n## Converting types from one to another\n\nNumerical can be converted to character,\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# To character\nfirst_vec_num\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 5\n```\n:::\n\n```{.r .cell-code}\nas.character(first_vec_num)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\" \"2\" \"5\"\n```\n:::\n:::\n\n\nwhile **not** all characters can be converted to numerical:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# To numeric\nfirst_vec_character\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"human\" \"mouse\" \"dog\"   \"cat\"  \n```\n:::\n\n```{.r .cell-code}\nas.numeric(first_vec_character)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA NA\n```\n:::\n\n```{.r .cell-code}\nas.numeric(mix_vec)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1 NA NA\n```\n:::\n:::\n\n:::\n\n#### Calculation with vectors\n\nR performs **element-wise operations** on vectors by default.\n\nExample: `c(1, 2, 3) + c(10, 20, 30)` returns `11 22 33`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 3) + c(10, 20, 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11 22 33\n```\n:::\n:::\n\n\n::: callout-tip\n## Vectorization\n\n-   **Vectorization** means operations are applied to **all elements at once**, without loops.\n\nIt's efficient and concise.\n\n-   Arithmetic operators (`+`, `-`, `*`, `/`, `^`) are **vectorized**.\n\nExample: `c(2, 4, 6) * 2` returns `4 8 12`\n\n-   Functions like `log()`, `sqrt()`, `exp()` are also **vectorized**.\n\nExample: `sqrt(c(4, 9, 16))` returns `2 3 4`\n\n-   When vectors are of **different lengths**, R **recycles** the shorter one (with a warning if not a multiple).\n\nExample: `c(1, 2, 3) + 1` returns `2 3 4`\n:::\n\n##### Task\n\nLet's go back and see what our variables are holding:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# short vector\nvec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\n# first vector\nfirst_vec_num\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 5\n```\n:::\n\n```{.r .cell-code}\n#second vector\nsecond_vec_num\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30\n```\n:::\n:::\n\n\n**What will be the outcome of these operations? Explain it with comment in the following code chunk!**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# vectorization: all elements in longer first vector were increased by 5\nfirst_vec_num + vec \n\n#\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_vec_num\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsecond_vec_num\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_vec_num + second_vec_num\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#\nfirst_vec_num * second_vec_num\n```\n:::\n\n\n### Subsetting vectors\n\nSubsetting is a way to access specific elements of a vector using **indexing**.\\\nTo extract one or more values, provide the corresponding indices inside **square brackets** (`[]`).\n\n::: callout-tip\n## Examples\n\n-   Selecting the second element\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_vec_num[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n-   Negative subsetting- meaning not selecting the second element\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_vec_num[-2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 5\n```\n:::\n:::\n\n\n-   Selecting first and third elements\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_vec_num[c(1,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 5\n```\n:::\n:::\n\n:::\n\nMoreover, selection can be done using other vectors, such as logical and numeric.\n\n##### Task\n\n**What happened when you used a logical vector for subsetting?**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_vec_num\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 5\n```\n:::\n\n```{.r .cell-code}\nfirst_vec_logic\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE  TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_vec_num[first_vec_logic]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_vec_num\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_vec_num[first_vec_num]\n```\n:::\n\n\n#### Adding and replacing elements\n\nIn R, you can modify vectors by **adding** new elements or **replacing** existing ones using indexing.\n\n-   To **add elements**, simply use the `c()` function to concatenate new values to the existing vector.\n-   To **replace elements**, use square bracket indexing and assign a new value to a specific position.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add new values to the end of the vector\nsecond_vec_num <- c(second_vec_num, 1, 30, 30, 30, 1, 1)\nsecond_vec_num\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30  1 30 30 30  1  1\n```\n:::\n\n```{.r .cell-code}\n# Replace the first element with a new value\nsecond_vec_num[1] <- 10000\nsecond_vec_num\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 10000     2     3     4     5     6     7     8     9    10    11    12\n[13]    13    14    15    16    17    18    19    20    21    22    23    24\n[25]    25    26    27    28    29    30     1    30    30    30     1     1\n```\n:::\n:::\n\n\n#### Boolean Operators\n\nBoolean operators in R (and other programming languages) are used to perform logical comparisons. They return `TRUE` or `FALSE` values based on whether a condition is met.\n\n| Operator | Description              | Example    | Result  |\n|----------|--------------------------|------------|---------|\n| `>`      | Greater than             | `5 > 6`    | `FALSE` |\n| `<`      | Less than                | `5 < 6`    | `TRUE`  |\n| `==`     | Equals to                | `10 == 10` | `TRUE`  |\n| `!=`     | Not equal to             | `10 != 10` | `FALSE` |\n| `>=`     | Greater than or equal to | `5 >= 6`   | `FALSE` |\n| `<=`     | Less than or equal to    | `6 <= 6`   | `TRUE`  |\n\n::: callout-tip\n## Examples\n\n-   Basic inequality: Is 2 not equal to 2?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 != 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n-   Compare a numeric vector to a single number (element-wise comparison)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_vec_num == 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE\n```\n:::\n:::\n\n\n-   Compare two vectors of unequal length\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_vec_num == first_vec_character\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in first_vec_num == first_vec_character: longer object length is not a\nmultiple of shorter object length\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE FALSE\n```\n:::\n:::\n\n:::\n\n##### Task\n\nIn the second example, we got a warning message ***longer object length is not a multiple of shorter object length*** and an output **FALSE FALSE FALSE FALSE**. *What happened here?*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Write your answer here\n```\n:::\n\n\n### Boolean with logical operators\n\n::: callout-tip\n## There are three types of logical operators in R\n\nAND operator **`&`**\n\nOR operator **`|`**\n\nNOT operator **`!`**\n:::\n\nExplain the examples below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_vec_num\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 5\n```\n:::\n\n```{.r .cell-code}\nfirst_vec_num == 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\nfirst_vec_num[first_vec_num == 5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\n###\nfirst_vec_num == 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\nfirst_vec_num == 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nfirst_vec_num == 5 & first_vec_num == 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\n##\nfirst_vec_num == 5 | first_vec_num == 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE  TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n####\nfirst_vec_num[first_vec_num == 5 & first_vec_num == 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nnumeric(0)\n```\n:::\n\n```{.r .cell-code}\nfirst_vec_num[first_vec_num == 5 | first_vec_num == 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 5\n```\n:::\n:::\n\n\n### Examples of useful function\n\n::: callout-tip\n## **Basic descriptive statistics**\n\n-   **`summary()`**\\\n    Provides a quick overview of an object. For numeric vectors or data frames, it returns the minimum, 1st quartile, median, mean, 3rd quartile, and maximum.\n\n-   **`mean()`**\\\n    Calculates the arithmetic average of a numeric vector.\n\n-   **`sum()`**\\\n    Adds all elements of a numeric vector together.\n\n-   **`sd()`**\\\n    Computes the standard deviation, which measures the amount of variation or dispersion in the data.\n\n-   **`table()`**\\\n    Creates a frequency table showing how often each value appears in a vector or factor.\n:::\n\nExample\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(c(10,10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n\n```{.r .cell-code}\n# Summary statistics\nsum(second_vec_num)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10557\n```\n:::\n\n```{.r .cell-code}\nsummary(second_vec_num)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n    1.00     7.75    16.50   293.25    25.25 10000.00 \n```\n:::\n\n```{.r .cell-code}\nsd(second_vec_num)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1664.043\n```\n:::\n\n```{.r .cell-code}\n# Count table\ntable( second_vec_num )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsecond_vec_num\n    1     2     3     4     5     6     7     8     9    10    11    12    13 \n    3     1     1     1     1     1     1     1     1     1     1     1     1 \n   14    15    16    17    18    19    20    21    22    23    24    25    26 \n    1     1     1     1     1     1     1     1     1     1     1     1     1 \n   27    28    29    30 10000 \n    1     1     1     4     1 \n```\n:::\n\n```{.r .cell-code}\ntable( c(\"dog\",\"dog\",\"dog\",\"cat\",\"cat\") )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\ncat dog \n  2   3 \n```\n:::\n:::\n\n\n::: callout-tip\n## **Vector inspection**\n\n-   **`length()`**\\\n    Returns the number of elements in a vector.\n\n-   **`unique()`**\\\n    Extracts the distinct (non-duplicate) values from a vector.\n\n-   **`anyNA()`**\\\n    Checks if there are any missing (`NA`) values in a vector and returns `TRUE` or `FALSE`.\n\n-   **`is.na()`**\\\n    Returns a logical vector indicating which elements are `NA`.\n\n-   **`sort()`**\\\n    Arranges the elements of a vector in ascending (default) or descending order.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Number of elements in vector\nlength(second_vec_num)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 36\n```\n:::\n\n```{.r .cell-code}\n# Order a vector\nsort_second_vec <- sort(second_vec_num, \n                          decreasing = FALSE)\nsecond_vec_num; sort_second_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 10000     2     3     4     5     6     7     8     9    10    11    12\n[13]    13    14    15    16    17    18    19    20    21    22    23    24\n[25]    25    26    27    28    29    30     1    30    30    30     1     1\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]     1     1     1     2     3     4     5     6     7     8     9    10\n[13]    11    12    13    14    15    16    17    18    19    20    21    22\n[25]    23    24    25    26    27    28    29    30    30    30    30 10000\n```\n:::\n\n```{.r .cell-code}\n# Count table\nsort( second_vec_num )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]     1     1     1     2     3     4     5     6     7     8     9    10\n[13]    11    12    13    14    15    16    17    18    19    20    21    22\n[25]    23    24    25    26    27    28    29    30    30    30    30 10000\n```\n:::\n\n```{.r .cell-code}\n# is there NA\nis.na( second_vec_num ) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nanyNA( second_vec_num )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n##### Task\n\n**What is the mean of every second element in the vector `second_vec_num`?**\n\n*Hard mode: Solve it in two different ways?*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Write the solution here\n\n# first way\nsecond_vec_num\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 10000     2     3     4     5     6     7     8     9    10    11    12\n[13]    13    14    15    16    17    18    19    20    21    22    23    24\n[25]    25    26    27    28    29    30     1    30    30    30     1     1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsum( second_vec_num[c(FALSE, TRUE)] )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 301\n```\n:::\n\n```{.r .cell-code}\nsecond_vec_num[c(FALSE, FALSE,TRUE)] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  3  6  9 12 15 18 21 24 27 30 30  1\n```\n:::\n\n```{.r .cell-code}\nsecond_vec_num[length(second_vec_num)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n## Matrix\n\nMatrix is a two dimensional data structure in R programming. It is similar to vector but additionally contains the dimension attribute.\n\n::: callout-tip\n## **Defining a matrix**\n\nYou define a matrix using the `matrix` function which takes data as vector, number of columns and/or rows to create a matrix. Argument `byrow` when FALSE is filling the matrix by columns\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# filling by rows\nfirst_mat <- matrix(1:20, nrow=5)\nfirst_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n```\n:::\n\n```{.r .cell-code}\n# filling by columns\nsecond_mat <- matrix(1:20, nrow=5,\n                        byrow=TRUE)\nsecond_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n[5,]   17   18   19   20\n```\n:::\n:::\n\n:::\n\n### Subsetting a matrix\n\nSince matrices are two dimensional, you have to subset in **both** dimensions. **Subsetting is done by opening square brackets with supplied index for each dimension separated by a comma**. Blank subsetting is useful because you keep all rows or all columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n```\n:::\n\n```{.r .cell-code}\nfirst_mat[1, 3:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11 16\n```\n:::\n\n```{.r .cell-code}\nfirst_mat[1:2, 3:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   11   16\n[2,]   12   17\n```\n:::\n:::\n\n\n### Replacing elements in a matrix\n\nYou can replace individual elements in a matrix using **indexing**. Here's an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access the element in the first row, first column\nfirst_mat[1,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\n# Replace that element with the character \"a\"\nfirst_mat[1,1] <- \"a\"\n# View the matrix\nfirst_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,] \"a\"  \"6\"  \"11\" \"16\"\n[2,] \"2\"  \"7\"  \"12\" \"17\"\n[3,] \"3\"  \"8\"  \"13\" \"18\"\n[4,] \"4\"  \"9\"  \"14\" \"19\"\n[5,] \"5\"  \"10\" \"15\" \"20\"\n```\n:::\n:::\n\n\n::: callout-tip\n## **Useful functions for matrices**\n\n-   **`dim()`** -- Returns or sets the dimensions of a matrix (rows, columns).\n-   **`nrow()`**, **`ncol()`** -- Get the number of rows or columns.\n-   **`t()`** -- Transposes the matrix (swaps rows and columns).\n-   **`rowSums()`**, **`colSums()`** -- Calculate row-wise or column-wise sums.\n-   **`rowMeans()`**, **`colMeans()`** -- Calculate means for each row or column.\n:::\n\n##### Task\n\n1.  Create a matrix called `second_matrix` using the vector `second_vec_num`.\n2.  Fill the matrix **by columns**.\n3.  Determine the **dimensions** of the matrix.\n4.  Calculate the **sum of each row**.\n5.  Calculate the **sum of each column**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Write the solution here\n\nsecond_matrix <- matrix(second_vec_num, \n                        nrow=5)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in matrix(second_vec_num, nrow = 5): data length [36] is not a\nsub-multiple or multiple of the number of rows [5]\n```\n:::\n\n```{.r .cell-code}\nsecond_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7]  [,8]\n[1,] 10000    6   11   16   21   26    1     1\n[2,]     2    7   12   17   22   27   30 10000\n[3,]     3    8   13   18   23   28   30     2\n[4,]     4    9   14   19   24   29   30     3\n[5,]     5   10   15   20   25   30    1     4\n```\n:::\n\n```{.r .cell-code}\n# dimensions\ndim(second_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 8\n```\n:::\n\n```{.r .cell-code}\nsecond_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7]  [,8]\n[1,] 10000    6   11   16   21   26    1     1\n[2,]     2    7   12   17   22   27   30 10000\n[3,]     3    8   13   18   23   28   30     2\n[4,]     4    9   14   19   24   29   30     3\n[5,]     5   10   15   20   25   30    1     4\n```\n:::\n\n```{.r .cell-code}\nrowSums(second_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10082 10117   125   132   110\n```\n:::\n\n```{.r .cell-code}\ncolSums(second_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10014    40    65    90   115   140    92 10010\n```\n:::\n:::\n\n\n## List\n\nList is an object containing elements of various types -- like strings, numbers, matrices, vectors, functions and another list inside it. The list is created using the `list()` function in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_list <- list(first = c(7,5,24,88),\n                   second = c(\"abc\", 3))\n\nfirst_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$first\n[1]  7  5 24 88\n\n$second\n[1] \"abc\" \"3\"  \n```\n:::\n:::\n\n\n### Accessing elements of a list\n\nYou can access elements of a list in several ways depending on whether you want:\n\n-   the actual value inside the list, or\n\n-   a sublist containing the element.\n\n::: callout-tip\n## Different subseting results in different object\n\n1.  If elements have names, you can access them with `$`. Here we have names the first stored element as first \"first\" and therefore we can call it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_list$first\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  7  5 24 88\n```\n:::\n:::\n\n\n2.  Using single brackets **`[]`**, we get a list\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_list[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$first\n[1]  7  5 24 88\n```\n:::\n:::\n\n\n3.  Using double brackets **`[[]]`**, we get a stored element\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_list[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  7  5 24 88\n```\n:::\n:::\n\n\n4.  Using double brackets **`[[ ]]`**, we access the actual stored element, and then we can subset it further if it's a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_list[[1]][2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n:::\n\n### Replacing and adding elements\n\nYou can both replace and add values within elements of a list using double brackets **`[[ ]]`** and indexing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Replace the first value in the first element of the list\nfirst_list[[1]][1] <- \"A\"\n```\n:::\n\n\nAdd a new value to a list element\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add a new (5th) value to the first element of the list\nfirst_list[[1]][5] <- \"x\" \n```\n:::\n\n\nView the result\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$first\n[1] \"A\"  \"5\"  \"24\" \"88\" \"x\" \n\n$second\n[1] \"abc\" \"3\"  \n```\n:::\n:::\n\n\n### List to vector\n\nIf you want to convert a list into a single atomic vector, you can use the `unlist()` function.\\\nThis flattens all elements of the list into a **single vector**, as long as the contents are compatible (e.g., numeric and character can both be coerced into character).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunlist(first_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n first1  first2  first3  first4  first5 second1 second2 \n    \"A\"     \"5\"    \"24\"    \"88\"     \"x\"   \"abc\"     \"3\" \n```\n:::\n\n```{.r .cell-code}\nfirst_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$first\n[1] \"A\"  \"5\"  \"24\" \"88\" \"x\" \n\n$second\n[1] \"abc\" \"3\"  \n```\n:::\n:::\n\n\n##### Taks\n\nThe **names** created when unlisting a list are automatically generated by R and reflect the structure of the original list.\n\n1.  First, save the result of `unlist` into a new vector called `unlist_first`.\n2.  Then, use the function `unname`.\\\n    What does this do?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Write the solution here\n\nunlist_first <- unlist(first_list)\n#\nunlist_first\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n first1  first2  first3  first4  first5 second1 second2 \n    \"A\"     \"5\"    \"24\"    \"88\"     \"x\"   \"abc\"     \"3\" \n```\n:::\n\n```{.r .cell-code}\nnames(unlist_first)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"first1\"  \"first2\"  \"first3\"  \"first4\"  \"first5\"  \"second1\" \"second2\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# unname\nunlist_first <- unname(unlist_first)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\r\n<script src=\"site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}