{"title":"Table manipulation","markdown":{"yaml":{"title":"Table manipulation","author":[{"name":"dr.sc. Paula Å tancl","affiliation":"Kuzman Consulting d.o.o"},{"name":"dr.sc. Andrea GelemanoviÄ‡","affiliation":"MedILS, UNIST"}],"format":{"html":{"self-contained":true,"toc":true,"toc-depth":5,"code-fold":false,"fig-align":"center","df-print":"paged","code-summary":"Show code","code-line-numbers":false,"code-tools":true}},"execute":{"echo":true,"warning":false,"message":false}},"headingText":"Tables (`data.frame` vs `data.table`)","containsRefs":false,"markdown":"\n\n\nA **`data.frame`** is a 2D table-like structure where columns can hold different data types. **`data.table`** is an enhanced version of **`data.frame`** that provides faster and more memory-efficient operations.\n\n::: callout-important\n## Built-in datasets\n\n-   R comes with several **built-in datasets** that are useful for learning, testing, and demonstrating functions without needing to load external data.\n\n-   These datasets are included in base R and standard packages like `datasets`, and can be accessed directly by name (e.g., **`CO2`**, **`iris`**, **`mtcars`**, etc.).\n:::\n\nWe will be working with build-in dataset **iris** introduced by Ronald Fisher in his 1936 paper *The use of multiple measurements in taxonomic problems*, contains three plant species (setosa, virginica, versicolor) and four features measured for each sample.\n\nLet's examine the first six rows of the table!\n\n```{r}\n# Call the table\nhead(iris)\n```\n\n+----------------+--------------------------------+-------------------------------------+\n| Feature        | `data.frame`                   | `data.table`                        |\n+================+================================+=====================================+\n| Base structure | Base R object                  | Extension of `data.frame`           |\n+----------------+--------------------------------+-------------------------------------+\n| Speed          | Moderate                       | Very fast, optimized for large data |\n+----------------+--------------------------------+-------------------------------------+\n| Syntax         | Verbose                        | Concise and powerful                |\n+----------------+--------------------------------+-------------------------------------+\n| Rownames       | Supported                      | Discouraged / ignored               |\n+----------------+--------------------------------+-------------------------------------+\n| Memory usage   | Standard                       | More memory-efficient               |\n+----------------+--------------------------------+-------------------------------------+\n| Grouping       | Uses `aggregate()` or `dplyr`  | Built-in with `by=`                 |\n+----------------+--------------------------------+-------------------------------------+\n| Joining        | Uses `merge()`                 | Fast joins with keys (`setkey()`)   |\n+----------------+--------------------------------+-------------------------------------+\n| Learning curve | Low (familiar to most R users) | Medium (different syntax)           |\n+----------------+--------------------------------+-------------------------------------+\n\n### Import different type of data\n\n::: callout-important\n## Functions to import the data\n\n-   basic R import function:\n\n    `df <- read.csv()`\n\n    `df <- read.tsv()`\n\n    `df <- read.table()`\n\n-   data.table import function:\n\n    `dt <- fread()`\n\n-   using specialized funcions from R packages to import files such as Excel, SPSS\n\n    `df <- read_excel()`\n\n    `df <- read.spss()`\n\n    `...`\n:::\n\n# Data.table\n\nTo use `data.table`, load the package:\n\n```{r}\nlibrary(data.table)\n```\n\n![](http://ryo-n7.github.io/assets/2019-07-21-user2019-reflections_files/datatableFORM.PNG){fig-align=\"center\"}\n\n## How to obtain data.table?\n\n::: callout-important\n# Import as data.table or convert existing formats to data.table\n\n1.  Import data using function **fread()**.\n\n**`dt_import <- fread(\"PATH/TO/FILE\")`**\n\n2.  Convert data.frame (even other objects such as matrices, GRanges object...) using **as.data.table()**.\n\n**`dt_import <- as.data.table(df)`**\n\n3.  Another approach of converting object to data.table using **setDT()** but without defining the new variable.\n\n**`setDT(df)`**\n:::\n\n::: callout-tip\nA **file path** tells R where to find or save a file.\n\n-   **Absolute path**: The full location starting from the root of your computer.\n    -   Example: `\"C:/Users/Paula/Documents/data.csv\"`\n-   **Relative path**: A shortcut from the current working directory.\n    -   Example: `\"data/data.csv\"`\n\nUse `getwd()` to check your current working directory.\n\nðŸ’¡ **Tip**: In RStudio Projects, use **relative paths** so your code works on any computer.\n:::\n\n## From *data.frame* to *data.table*\n\nRun the code chunk below. If you want, check it out using **rownames()**.\n\n```{r}\n( df_letters <- data.frame( one=1:6, two=2:7, row.names=letters[1:6]) )\n( dt_letters <- as.data.table(df_letters) )\n```\n\n### How to keep the rownames?\n\nSet argument ***keep.rownames*** to TRUE if you want to keep the rownames as a separate column in data.table.\n\n```{r}\n( dt_letters <- as.data.table(df_letters, keep.rownames=TRUE) )\n```\n\nInstead of keep.rownames=TRUE, you can specify the name of the column containing the rownames from the data.frame.\n\nExample:\n\n```{r}\n( dt_letters <- as.data.table(df_letters, keep.rownames=\"letters\") )\n```\n\n#### Task example: Convert ***iris*** to data table using as.data.table\n\nCreate a variable **iris_dt** that contains iris data set as data.table object. In this tutorial we are going to compare and analyze the default data set ***iris*** as data frame and data table objects.\n\n```{r}\niris_dt <- as.data.table(iris)\n\n\niris\nrownames(iris)\nrownames(iris_dt)\n```\n\n## Row subsetting\n\n### Syntax comparison\n\n+----------------------------------+-------------------+---------------+\n| Operation                        | *data.frame*      | ```           |\n|                                  |                   | _data.table_  |\n|                                  |                   | ```           |\n+==================================+===================+===============+\n| Subseting rows                   | `df[1:20, ]`      | `df[1:20]`    |\n+----------------------------------+-------------------+---------------+\n| Subseting rows based on criteria | `df[df$id < 4, ]` | `df[id < 4]`  |\n+----------------------------------+-------------------+---------------+\n\n##### Task\n\nSelect all rows in **iris_dt** with Sepal.Length less than 6.7 and Petal.Length less than 1.2.\n\n```{r}\n# Write the solution here\n\niris_dt[Sepal.Length < 6.7 & Petal.Length < 1.2]\n```\n\nSelect only setosa species with more than 0.3 Petal.Width.\n\n```{r}\n# Write the solution here\niris_dt[Species == \"setosa\" & Petal.Width < 0.3]\n```\n\n## Column subsetting\n\n### Syntax comparison\n\n+-------------------------------------+-----------------+----------------+\n| Operation                           | *data.frame*    | ```            |\n|                                     |                 | _data.table_   |\n|                                     |                 | ```            |\n+=====================================+=================+================+\n| Subseting columns                   | `df[, c(1,5)]`  | `df[, c(1,5)]` |\n+-------------------------------------+-----------------+----------------+\n| Subseting columns based on colnames | `df[, c(\"id\")]` | `df[,.(id)]`   |\n+-------------------------------------+-----------------+----------------+\n\n::: callout-important\n*Data.table* does not use **c()** but **.()** which represents list\n:::\n\nSelect columns Petal.Length and Petal.Width and first 3 rows\n\n```{r}\n# Write the solution here\n\niris_dt[ 1:3, .(Petal.Length, Petal.Width) ]\n```\n\n### Additional methods of subsetting columns in data.table\n\n::: callout-tip\n1.  **Using a character vector of column names**\n\nYou can store column names in a vector and use `..` to evaluate it inside `data.table`.\n\n```{r}\ncnames <- c(\"Petal.Length\", \"Petal.Width\")\n\niris_dt[1:3, ..cnames]\n```\n\n2.  **Using a range of column names**\n\nYou can select a range of columns using the `:` operator between two column names.\n\n```{r}\niris_dt[1:3, Sepal.Length:Petal.Width]\n```\n\n3.  **Negative subsetting to exclude columns**\n\nUse `-()` or `!()` to exclude a range of columns.\n\n```{r}\niris_dt[1:3, -(Sepal.Length:Petal.Width)]\n\niris_dt[1:3, !(Sepal.Length:Petal.Length)]\n```\n\nNote: `Sepal.Length:Petal.Width` works only in column context---it is not the same as numeric indexing.\n:::\n\n##### Task\n\nSelect all rows in **iris_dt** with Sepal.Width equal to **3.0**, but show only columns for **Species** and *Sepal.Width* (Do it by using column names!). You may also try other methods of subsetting.\n\n```{r}\n# Write the solution here\n```\n\n## Operation on columns\n\n### Syntax comparison\n\n+--------------------------------+--------------------------------+---------------------------+\n| Operation                      | *data.frame*                   | *data.table*              |\n+================================+================================+===========================+\n| Calculate sum                  | `sum(df$id)`                   | `df[, sum(id)]`           |\n+--------------------------------+--------------------------------+---------------------------+\n| Calculate sum by group         | `by(df$id,` `df$group,` `sum)` | `df[, sum(id), by=group]` |\n+--------------------------------+--------------------------------+---------------------------+\n| Calling column out as a vector | `df$id`                        | `df[, id]`                |\n+--------------------------------+--------------------------------+---------------------------+\n\nCalculate mean of Sepal.Width for all species.\n\n```{r}\niris_dt[, mean(Sepal.Width)]\n```\n\nCalculate mean of Sepal.Width for and for each species\n\n```{r}\niris_dt[, mean(Sepal.Width), by=Species] \n```\n\nAlso the following syntax works for data.table because in the third part it is always the group operation when calculating something per rows: `iris_dt[, mean(Sepal.Width), Species]`\n\n::: callout-important\n# Adding the column immediately when performing the operation in data.table\n\nSyntax: `df[, .(new_col = sum(id) ), by=group]`\n\nExample:\n\n```{r}\niris_dt[, .( mean_col = mean(Sepal.Width) ), by=Species]\n```\n:::\n\n### The power of *data.table* over *data.frame*\n\n`data.table` offers an elegant and efficient way to perform multiple calculations on columns and save the results --- all in a concise syntax.\n\nExample: Calculate mean, standard deviation, max, min, and count of `Sepal.Width` by Species, then order by mean. ::: callout-important With `data.table`, you can chain multiple operations using square brackets `[]`, similar in spirit to the `dplyr` pipe `%>%`. :::\n\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| *data.frame*                                                                                                                                                                                                                                                 | *data.table*                                                                                                                                                    |\n+==============================================================================================================================================================================================================================================================+=================================================================================================================================================================+\n| <font size=\"4\">`meanic <- by(iris$Sepal.Width,INDICES = iris$Species, mean)` `sdic <- by(iris$Sepal.Width,INDICES = iris$Species, sd)` `maxx <- by(iris$Sepal.Width,INDICES = iris$Species, max)` `minx <- by(iris$Sepal.Width,INDICES = iris$Species, min)` | <font size=\"4\">`iris_dt[ ,` `.(mean=mean(Sepal.Width),` `sd=sd(Sepal.Width),` `min_x= min(Sepal.Width),` `max_x= max(Sepal.Width)),` `by=Species][order(mean)]` |\n|                                                                                                                                                                                                                                                              |                                                                                                                                                                 |\n| `res_df <- data.frame(as.numeric(meanic),` `as.numeric(sdic),` `as.numeric(maxx),` `as.numeric(minx))`                                                                                                                                                       | </font>                                                                                                                                                         |\n|                                                                                                                                                                                                                                                              |                                                                                                                                                                 |\n| `res_df[order(res_df$as.numeric.meanic.),]`</font>                                                                                                                                                                                                           |                                                                                                                                                                 |\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+\n\nOutput example\n\n```{r}\niris_dt[ , \n        .(mean=mean(Sepal.Width),\n          sd=sd(Sepal.Width),\n          min_x= min(Sepal.Width),\n          max_x= max(Sepal.Width)),\n        by=Species][order(mean)]\n```\n\n##### Task\n\nSelect all rows where Sepal.Length \\< 6.7 and flower species **virginica** and calculate mean Petal.Width in **iris_dt.** Do it with and without chaining.\n\n*With chaining*\n\n```{r}\n# Write the solution here\n```\n\n*No chaining*\n\n```{r}\n# Write the solution here\n```\n\n### Adding new permanent columns\n\nAdding one columns in data table is done with **:=** and multiple columns with **':='**.\n\nHere is a new column that contains the maximal sepal width for each species was added.\n\n```{r}\niris_dt[, max_width1 := max(Sepal.Width), Species]\niris_dt[1:3]\n```\n\nAddition of multiple columns.\n\n```{r}\niris_dt[, \":=\" (max_width2 = max(Sepal.Width),  \n                max_width3 = max(Sepal.Length) ),\n        by=.(Species)]\niris_dt[1:3]\n```\n\n##### Task: Add a new column\n\nAdd columns to iris_dt that represent mean and sd of `Petal.Width` grouped by species. Columns are called **meanPW** and **sdPW**.\n\n```{r}\n# Write the solution here\n\niris_dt[, \":=\" (meanPW = mean(Petal.Width),  \n                sdPW = sd(Petal.Width) ),\n        by=.(Species)]\niris_dt[1:3]\n\n###how to remove columns :D \niris_dt[, sdPW := NULL]\niris_dt[1:3]\n```\n\nUse function **uniqueN()** to check how many unique mean `Petal.Width` there are in total and by Species group.\n\n```{r}\n# Write the solution here\n```\n\n### Special symbols in data.table\n\n**.N** (an integer containing the number of rows in the group)\n\n```{r}\niris_dt[, .N]\n```\n\nCan be used on groups. What is happening here with this subsetting in group?\n\n```{r}\niris_dt[, .N, by=.(Species, Sepal.Length>=4.8)]\n```\n\n##### Task: :=, .N\n\nAdd columns to **iris_dt** that represent number of observations of all rows for which Petal.Length is smaller than 6.5 in **iris_dt** grouped by species.\n\n```{r}\n# Write the solution here\n```\n\nMoreover, show only the newly added columns in your final results and use `na.omit()` to remove all missing values from your table\n\n```{r}\n# Write the solution here\n```\n\nOne great benefit of data.table is the ability to **sub-assign by reference**: Try it: select all rows that have species==\"virginica\" and rename those Species entries using `:=` to `new_virginica`.\n\n```{r}\n# Write the solution here\n```\n\n## Subset of the original Data.table\n\n**.SD** (a smaller data.table that is a **Subset** of the original **Data.table** for each group)\n\n**.SDcols** (subset columns which are then used by .SD)\n\n-   Select all columns with .SD. Select only a subset of all columns by .SDcols\n\n```{r, echo=FALSE,  fig.align='center'}\nimg2 <- png::readPNG(\"input/SDcols.png\")\ngrid::grid.raster(img2)\n```\n\nSelecting columns can be done by writing column names in .SDcols (Note: It is important to write it as stings in *c()* )\n\n```{r}\niris_dt[, .SD, .SDcols=c(\"Sepal.Width\", \"Species\")][1:2]\n```\n\nThis allows powerful calculation on subset of desired columns and groups.\n\n```{r, echo=FALSE,  fig.align='center'}\nimg3 <- png::readPNG(\"input/SDcols_grp.png\")\ngrid::grid.raster(img3)\n```\n\nYou can use `lapply()` together with `.SD` (Subset of Data) to apply functions to selected columns within groups. This is particularly useful for performing calculations like mean or sum on a subset of numeric columns.\n\n```{r}\niris_dt[, lapply(.SD, mean), by=Species, .SDcols=1:2]\n```\n\nApply mean to all numeric columns by species\n\n```{r}\niris_dt[, lapply(.SD, mean), by=Species, .SDcols=is.numeric]\n```\n\n.SD is amazing for selecting first and last row of certain group since we can imagine every group with selected table as a new separate data table. As well as other operation that can be done on *data.table*.\n\n```{r, echo=FALSE, fig.align='center'}\nimg4 <- png::readPNG(\"input/SDcols_grp_filter.png\")\ngrid::grid.raster(img4)\n```\n\n```{r}\niris_dt[, .SD[c(1, .N)], by=Species]\n```\n\n##### Task: .SD\n\nOrder the results by Petal.Width and select first three (smallest) observations by species. Calculate mean of first three columns for iris_dt for those observations. Do it in one command with chaining.\n\n```{r}\n# Write the solution here\n```\n\n------------------------------------------------------------------------\n\n## Combining tables\n\n### Binding tables\n\nHow to \"stitch\" two or more data objects into one?\n\n```{r}\ntb1 <- data.table(sampleID = c(6:1),\n                  cancer = c(\"Breast\",\"Breast\",\"Brain\",\"Liver\",\"Brain\",\"Pancreas\"))\ntb2 <- data.table(sampleID = c(7, 4, 6, 2, 8), \n                  gender = c(\"F\",\"F\",\"M\",\"F\",\"M\")) \nhead(tb1,3)\nhead(tb2,3)\n```\n\nFunction **rbind()** binds the tables by rows. Try run the code below and see what happens. Why is that?\n\n```{r, error=TRUE}\nrbind(tb1, tb2)\n```\n\n```{r}\nrbind(tb1, tb2, fill=TRUE)\n```\n\nFunction **cbind()** binds the tables. Do you notice anything strange when you run the code below?\n\n```{r}\ncbind(tb1, tb2)\n```\n\n### `merge()`\n\n![](https://www.edureka.co/blog/content/ver.1554115042/uploads/2019/03/Joins-in-SQL-SQL-Joins-Edureka.png){fig-align=\"center\"}\n\nSpecify by which column you want to merge by and set the argument **all=** to TRUE to perform the full join\n\n```{r}\nmerge(tb1, tb2, by=\"sampleID\") #if setkey was used prior then merge(tb1,tb2) works the same\nmerge(tb1, tb2, by=\"sampleID\", all=TRUE)\n```\n\nRight and left join\n\n```{r}\nmerge(tb1, tb2, by=\"sampleID\", all.x = TRUE)\nmerge(tb1, tb2, by=\"sampleID\", all.y = TRUE)\n```\n\n## Tidying the table\n\nTidying a data table often includes renaming columns to make them more informative or consistent.\n\n::: callout-tip\nYou can rename columns using `names()` or `colnames()`.\n\n`names(dt_cancer) <- vec_names`\n:::\n\n```{r col_names1, exercise=TRUE, exercise.setup = \"cancer\"}\ndt_cancer <- merge(tb1, tb2, by=\"sampleID\", all=TRUE)\ndt_cancer\nnames(dt_cancer)[1] <- \"id\"\ndt_cancer\n```\n\n::: callout-tip\nYou can rename columns using data.table: `setnames`\n\n`setnames(dt_cancer, \"old_names\", \"new_names\")`\n:::\n\n```{r}\nnames(dt_cancer)\nsetnames(dt_cancer,  \"id\", \"sampleID\")\nnames(dt_cancer)\n```\n\n### Ordering columns\n\nSubseting\n\n`dt[,.(col3, col10, col2)]`\n\n```{r col_order1, exercise=TRUE, exercise.setup = \"cancer\"}\ndt_cancer[,.(gender, sampleID)]\n```\n\ndata.table: setcolorder()\n\n`setcolorder(dt_cancer, neworder)`\n\n```{r col_order2, exercise=TRUE, exercise.setup = \"cancer\"}\ndt_cancer\nsetcolorder(dt_cancer, c(\"gender\",\"sampleID\"))\ndt_cancer\n```\n\n## Reshaping the table\n\nYou can create a modified version of an existing `data.table` by using `copy()` to avoid changing the original data. Then, use `:=` to add or modify columns by reference.\n\nIn the example below, we create two new columns (`BRCA2` and `ATM`) filled with random values between 40 and 6000 for 6 rows:\n\n```{r}\ntb.shape <- copy(tb1)\ntb.shape[, \":=\" (\n            BRCA2=sample(40:6000,6),\n            ATM=sample(40:6000,6)) ]\n\ntb.shape\n```\n\n**`melt (wide to long)`**\n\nConvert DT to long form where money is a separate observation. **measure.vars** specify the set of columns we would like to collapse (or combine) together.\n\n```{r}\nmelt(tb.shape, id.vars = c(\"sampleID\", \"cancer\"),\n                measure.vars = c(\"BRCA2\", \"ATM\"))\n```\n\nWe can also specify column indices instead of names.\n\n```{r}\n(tb1.m1  <- melt(tb.shape, \n                 measure.vars = c(\"BRCA2\", \"ATM\"),\n                 variable.name = \"genes\",\n                 value.name = \"n_mutations\")  \n )\n```\n\n**`dcast (long to wide)`**\n\nWe want to get the original table from the previous reshaped one using **dcast()**\n\n```{r}\ndcast(tb1.m1, sampleID + cancer ~ genes, value.var = \"n_mutations\")\n```\n\n## Saving a table with `fwrite()`\n\nThe `fwrite()` function from the `data.table` package is a fast and efficient way to write data tables to disk.\n\n::: callout-tip\nfwrite(dt, file = \"results/iris_summary.csv\")\n:::\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"center","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"self-contained":true,"toc-depth":5,"output-file":"Day2_IRB25_part1.html"},"language":{"code-summary":"Show code"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.335","editor":"visual","theme":"styles.scss","mainfont":"Nunito","page-layout":"full","title":"Table manipulation","author":[{"name":"dr.sc. Paula Å tancl","affiliation":"Kuzman Consulting d.o.o"},{"name":"dr.sc. Andrea GelemanoviÄ‡","affiliation":"MedILS, UNIST"}]},"extensions":{"book":{"multiFile":true}}}}}