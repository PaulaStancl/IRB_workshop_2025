{"title":"Introduction to R","markdown":{"yaml":{"title":"Introduction to R","author":[{"name":"dr.sc. Paula Štancl","affiliation":"Kuzman Consulting d.o.o"},{"name":"dr.sc. Andrea Gelemanović","affiliation":"MedILS, UNIST"}],"format":{"html":{"self-contained":true,"toc":true,"toc-depth":5,"code-fold":false,"fig-align":"center","df-print":"paged","code-summary":"Show code","code-line-numbers":false,"code-tools":true}},"execute":{"echo":true,"message":false,"collapse":true}},"headingText":"How to quickly code a chunk","containsRefs":false,"markdown":"\n\nHello everyone to your first session \"Introduction to R\" in the Institute Ruder Boskovic (IRB) workshop. During this session, you will learn the basics to R programming and working environment.\n\n::: callout-tip\n\n**Ctrl + Alt + I**\n:::\n\n# R as calculator\n\nR can be used as a basic calculator to perform arithmetic operations like addition, subtraction, multiplication, and division.\n\n| Expression        | Description                  | Result |\n|-------------------|------------------------------|--------|\n| `(9 + 2)*(3 - 1)` | Multiply sum and difference  | `22`   |\n| `sqrt(2)^2`       | Square of square root of 2   | `2`    |\n| `5 / 2`           | Division (gives decimal)     | `2.5`  |\n| `5 %/% 2`         | Integer (floor) division     | `2`    |\n| `5 %% 2`          | Remainder (modulo operation) | `1`    |\n\n##### Task\n\nA scientist has **48** stem cells. Each one divides into **2** daughter cells.\n\n-   How many cells will there be after division?\n\n-   How many full groups of **10 cells** can you make after first division? How many left over?\n\n```{r}\n# Solve here\n2+2\n```\n\n\n# R objects\n\n## Variable\n\n### Creating a variable\n\nTo create a certain object, you need to give it a name followed by the assignment operator **\\<-** and the value you want to store it. To see the stored value in a variable, you can call it using *parentheses* or *by typing the object name*.\n\n```{r}\nvec <- 5\n# Print\nvec\n# Print\n(vec2 <- 10)\n```\n\n### Naming a variable\n\nWhen naming the variables, they mustn't be too short or too long. Avoid meaningless variable names and name them logically ( example: **`mRNA_human`** ) R is case sensitive ( example: **`vec`** is different to **`Vec`** ). Some names cannot be used because they are the names of fundamental functions in R (e.g., **`if`**, **`else`**, **`for`**...). In general, even if it's allowed, it's best to not use other function names (e.g., **`c`**, **`t`**, **`mean`**, **`data`**, **`df`**). Furthermore, avoid using dots (**`.`**) within a variable name, such as in `my.mRNA`. A lot of functions in R have dots in their name for historical reasons and dots have special meaning in R so it is best to avoid them.\n\n## Functions and useful tricks\n\nFunctions are \"conserved scripts\" that automate more complicated sets of commands including operations assignments, etc. Many functions are predefined, or can be made available by importing R packages (more on that later). A function usually gets one or more inputs called arguments. Functions often (but not always) return a value. Adding `?` in front of any function opens a help, description and usage of the function. A typical example function is `typeof`.\n\n::: callout-tip\n## Help with functions\n\nWhat does the function type do?\n\n(Hint: ?typeof)\n:::\n\n```{r, eval=FALSE}\n?typeof\n```\n\n## Vectors\n\nA vector is the most common and basic data type in R. A vector is composed by a series of values. V ectors can be composed of integer/numeric, logical or character values. Using the **`c()`**function you can assign a series of values to a vector. The simplest way to create a sequence of numbers in R is by using the **`:`** operator.\n\nExamples of defining vectors\n\n```{r}\n( first_vec_num <- c(1,2,5) )\n#The simplest way to create a sequence of numbers in R is by using the : operator. \n( second_vec_num <- 1:30 )\n( first_vec_character <- c(\"human\", \"mouse\", \"dog\", \"cat\") )\n( first_vec_logic <- c(TRUE, FALSE, TRUE) )\n# create a vector containing different types\n( mix_vec <-c(1, \"sea\", TRUE) )\n```\n\n### Different types and classes\n\n#### Types\n\n-   character\n\n-   double (for double precision floating point numbers)\n\n-   integer\n\n::: callout-tip\n## **Useful functions for determining types**\n\n-   **`class()`**\\\n    Returns the class of an object (e.g., `\"numeric\"`, `\"character\"`, `\"data.frame\"`), giving a general idea of its structure.\n\n-   **`typeof()`**\\\n    Provides the low-level internal storage type of an object (e.g., `\"double\"`, `\"integer\"`, `\"list\"`), which can be more specific than `class()`.\n\n-   **`is.numeric()`**, **`is.character()`**, **`is.logical()`**, etc.\\\n    Return `TRUE` or `FALSE` depending on whether the object is of the specified type. These are useful for checking expected input types in functions.\n\n-   **`as.numeric()`**, **`as.character()`**, **`as.logical()`**, etc.\\\n    Coerce (convert) an object to the specified type, if possible. These are helpful when transforming data types explicitly.\n\n-   **`str()`**\\\n    Provides a compact, readable summary of the structure of an R object, including its type, dimensions, and content preview.\n:::\n\nWhat are the types of our objects?\n\n```{r}\n# double/numeric\ntypeof(first_vec_num)\n# character\ntypeof(first_vec_character)\n# logical\ntypeof(first_vec_logic)\n# character\ntypeof(mix_vec)\n```\n\n::: callout-warning\n## Converting types from one to another\n\nNumerical can be converted to character,\n\n```{r}\n# To character\nfirst_vec_num\nas.character(first_vec_num)\n\n```\n\nwhile **not** all characters can be converted to numerical:\n\n```{r}\n# To numeric\nfirst_vec_character\nas.numeric(first_vec_character)\nas.numeric(mix_vec)\n```\n:::\n\n#### Calculation with vectors\n\nR performs **element-wise operations** on vectors by default.\n\nExample: `c(1, 2, 3) + c(10, 20, 30)` returns `11 22 33`\n\n```{r}\nc(1, 2, 3) + c(10, 20, 30)\n```\n\n::: callout-tip\n## Vectorization\n\n-   **Vectorization** means operations are applied to **all elements at once**, without loops.\n\nIt's efficient and concise.\n\n-   Arithmetic operators (`+`, `-`, `*`, `/`, `^`) are **vectorized**.\n\nExample: `c(2, 4, 6) * 2` returns `4 8 12`\n\n-   Functions like `log()`, `sqrt()`, `exp()` are also **vectorized**.\n\nExample: `sqrt(c(4, 9, 16))` returns `2 3 4`\n\n-   When vectors are of **different lengths**, R **recycles** the shorter one (with a warning if not a multiple).\n\nExample: `c(1, 2, 3) + 1` returns `2 3 4`\n:::\n\n##### Task\n\nLet's go back and see what our variables are holding:\n\n```{r}\n# short vector\nvec\n# first vector\nfirst_vec_num\n#second vector\nsecond_vec_num\n```\n\n**What will be the outcome of these operations? Explain it with comment in the following code chunk!**\n\n```{r, eval = FALSE}\nfirst_vec_num + vec \n\nfirst_vec_num + second_vec_num\n\nfirst_vec_num * second_vec_num\n```\n\n### Subsetting vectors\n\nSubsetting is a way to access specific elements of a vector using **indexing**.\\\nTo extract one or more values, provide the corresponding indices inside **square brackets** (`[]`).\n\n::: callout-tip\n## Examples\n\n-   Selecting the second element\n\n```{r}\nfirst_vec_num[2]\n```\n\n-   Negative subsetting- meaning not selecting the second element\n\n```{r}\nfirst_vec_num[-2]\n```\n\n-   Selecting first and third elements\n\n```{r}\nfirst_vec_num[c(1,3)]\n```\n:::\n\nMoreover, selection can be done using other vectors, such as logical and numeric.\n\n##### Task\n\n**What happened when you used a logical vector for subsetting?**\n\n```{r, eval=FALSE}\nfirst_vec_num[first_vec_logic]\n\nfirst_vec_num[first_vec_num]\n```\n\n#### Adding and replacing elements\n\nIn R, you can modify vectors by **adding** new elements or **replacing** existing ones using indexing.\n\n-   To **add elements**, simply use the `c()` function to concatenate new values to the existing vector.\n-   To **replace elements**, use square bracket indexing and assign a new value to a specific position.\n\n```{r}\n# Add new values to the end of the vector\nsecond_vec_num <- c(second_vec_num, 1, 30, 30, 30, 1, 1)\nsecond_vec_num\n\n# Replace the first element with a new value\nsecond_vec_num[1] <- 10000\nsecond_vec_num\n```\n\n#### Boolean Operators\n\nBoolean operators in R (and other programming languages) are used to perform logical comparisons. They return `TRUE` or `FALSE` values based on whether a condition is met.\n\n| Operator | Description              | Example    | Result  |\n|----------|--------------------------|------------|---------|\n| `>`      | Greater than             | `5 > 6`    | `FALSE` |\n| `<`      | Less than                | `5 < 6`    | `TRUE`  |\n| `==`     | Equals to                | `10 == 10` | `TRUE`  |\n| `!=`     | Not equal to             | `10 != 10` | `FALSE` |\n| `>=`     | Greater than or equal to | `5 >= 6`   | `FALSE` |\n| `<=`     | Less than or equal to    | `6 <= 6`   | `TRUE`  |\n\n::: callout-tip\n## Examples\n\n-   Basic inequality: Is 2 not equal to 2?\n\n```{r}\n2 != 2\n```\n\n-   Compare a numeric vector to a single number (element-wise comparison)\n\n```{r}\nfirst_vec_num == 2\n```\n\n-   Compare two vectors of unequal length\n\n```{r}\nfirst_vec_num == first_vec_character\n```\n:::\n\n##### Task\n\nIn the second example, we got a warning message ***longer object length is not a multiple of shorter object length*** and an output **FALSE FALSE FALSE FALSE**. *What happened here?*\n\n```{r}\n# Write your answer here\n```\n\n### Boolean with logical operators\n\n::: callout-tip\n## There are three types of logical operators in R\n\nAND operator **`&`**\n\nOR operator **`|`**\n\nNOT operator **`!`**\n:::\n\nExplain the examples below:\n\n```{r}\nfirst_vec_num[first_vec_num == 5 & first_vec_num == 2]\nfirst_vec_num[first_vec_num == 5 | first_vec_num == 2]\n```\n\n### Examples of useful function\n\n::: callout-tip\n## **Basic descriptive statistics**\n\n-   **`summary()`**\\\n    Provides a quick overview of an object. For numeric vectors or data frames, it returns the minimum, 1st quartile, median, mean, 3rd quartile, and maximum.\n\n-   **`mean()`**\\\n    Calculates the arithmetic average of a numeric vector.\n\n-   **`sum()`**\\\n    Adds all elements of a numeric vector together.\n\n-   **`sd()`**\\\n    Computes the standard deviation, which measures the amount of variation or dispersion in the data.\n\n-   **`table()`**\\\n    Creates a frequency table showing how often each value appears in a vector or factor.\n:::\n\nExample\n\n```{r}\nsum(c(10,10))\n# Summary statistics\nsum(second_vec_num)\nsummary(second_vec_num)\n# Count table\ntable( second_vec_num )\n```\n\n::: callout-tip\n## **Vector inspection**\n\n-   **`length()`**\\\n    Returns the number of elements in a vector.\n\n-   **`unique()`**\\\n    Extracts the distinct (non-duplicate) values from a vector.\n\n-   **`anyNA()`**\\\n    Checks if there are any missing (`NA`) values in a vector and returns `TRUE` or `FALSE`.\n\n-   **`is.na()`**\\\n    Returns a logical vector indicating which elements are `NA`.\n\n-   **`sort()`**\\\n    Arranges the elements of a vector in ascending (default) or descending order.\n:::\n\n```{r}\n# Number of elements in vector\nlength(second_vec_num)\n\n# Order a vector\nsort_second_vec <- sort(second_vec_num, \n                          decreasing = FALSE)\nsecond_vec_num; sort_second_vec\n\n# Count table\nsort( second_vec_num )\n\n# is there NA\nis.na( second_vec_num ) \nanyNA( second_vec_num )\n```\n\n##### Task\n\n**What is the mean of every second element in the vector `second_vec_num`?**\n\n*Hard mode: Solve it in two different ways?*\n```{r}\n# Write the solution here\n```\n\n\n## Matrix\n\nMatrix is a two dimensional data structure in R programming. It is similar to vector but additionally contains the dimension attribute.\n\n::: callout-tip\n## **Defining a matrix**\n\nYou define a matrix using the `matrix` function which takes data as vector, number of columns and/or rows to create a matrix. Argument `byrow` when FALSE is filling the matrix by columns\n\n```{r}\n# filling by rows\nfirst_mat <- matrix(1:20, nrow=5)\nfirst_mat\n# filling by columns\nsecond_mat <- matrix(1:20, nrow=5,\n                        byrow=TRUE)\nsecond_mat\n```\n:::\n\n### Subsetting a matrix\n\nSince matrices are two dimensional, you have to subset in **both** dimensions. **Subsetting is done by opening square brackets with supplied index for each dimension separated by a comma**. Blank subsetting is useful because you keep all rows or all columns.\n\n```{r}\nfirst_mat\nfirst_mat[1, 3:4]\nfirst_mat[1:2, 3:4]\n```\n\n### Replacing elements in a matrix\n\nYou can replace individual elements in a matrix using **indexing**. Here's an example:\n\n```{r}\n# Access the element in the first row, first column\nfirst_mat[1,1]\n# Replace that element with the character \"a\"\nfirst_mat[1,1] <- \"a\"\n# View the matrix\nfirst_mat\n```\n\n\n::: callout-tip\n## **Useful functions for matrices**\n\n-   **`dim()`** – Returns or sets the dimensions of a matrix (rows, columns).\n-   **`nrow()`**, **`ncol()`** – Get the number of rows or columns.\n-   **`t()`** – Transposes the matrix (swaps rows and columns).\n-   **`rowSums()`**, **`colSums()`** – Calculate row-wise or column-wise sums.\n-   **`rowMeans()`**, **`colMeans()`** – Calculate means for each row or column.\n\n:::\n\n##### Task\n\n1. Create a matrix called `second_matrix` using the vector `second_vec_num`.\n2. Fill the matrix **by columns** (default behavior).\n3. Determine the **dimensions** of the matrix.\n4. Calculate the **sum of each row**.\n5. Calculate the **sum of each column**.\n\n```{r}\n# Write the solution here\n```\n\n\n\n## List\n\nList is an object containing elements of various types -- like strings, numbers, matrices, vectors, functions and another list inside it. The list is created using the `list()` function in R.\n\n```{r}\nfirst_list <- list(first = c(7,5,24,88),\n                   second = c(\"abc\", 3))\n\nfirst_list\n```\n\n### Accessing elements of a list\n\nYou can access elements of a list in several ways depending on whether you want:\n\n-   the actual value inside the list, or\n\n-   a sublist containing the element.\n\n::: callout-tip\n## Different subseting results in different object\n\n1.  If elements have names, you can access them with `$`. Here we have names the first stored element as first \"first\" and therefore we can call it.\n\n```{r}\nfirst_list$first\n```\n\n2.  Using single brackets **`[]`**, we get a list\n```{r}\nfirst_list[1]\n```\n\n3.  Using double brackets **`[[]]`**, we get a stored element\n```{r}\nfirst_list[[1]]\n```\n\n4. Using double brackets **`[[ ]]`**, we access the actual stored element, and then we can subset it further if it's a vector.\n```{r}\nfirst_list[[1]][2]\n```\n:::\n\n\n### Replacing and adding elements\n\nYou can both replace and add values within elements of a list using double brackets **`[[ ]]`** and indexing.\n\n```{r}\n# Replace the first value in the first element of the list\nfirst_list[[1]][1] <- \"A\"\n```\n\nAdd a new value to a list element\n\n```{r}\n# Add a new (5th) value to the first element of the list\nfirst_list[[1]][5] <- \"x\" \n```\n\nView the result\n\n```{r}\nfirst_list\n```\n\n### List to vector\n\nIf you want to convert a list into a single atomic vector, you can use the `unlist()` function.  \nThis flattens all elements of the list into a **single vector**, as long as the contents are compatible (e.g., numeric and character can both be coerced into character).\n\n```{r}\nunlist(first_list)\nfirst_list\n```\n\n##### Taks\n\n\nThe **names** created when unlisting a list are automatically generated by R and reflect the structure of the original list.\n\n1. First, save the result of `unlist` into a new vector called `unlist_first`.\n2. Then, use the function `unname`.  \n   What does this do?\n\n```{r}\n# Write the solution here\n```\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"collapse":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"center","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"self-contained":true,"toc-depth":5,"output-file":"Day1_IRB25_part1.html"},"language":{"code-summary":"Show code"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.335","editor":"visual","theme":"styles.scss","mainfont":"Nunito","page-layout":"full","title":"Introduction to R","author":[{"name":"dr.sc. Paula Štancl","affiliation":"Kuzman Consulting d.o.o"},{"name":"dr.sc. Andrea Gelemanović","affiliation":"MedILS, UNIST"}]},"extensions":{"book":{"multiFile":true}}}}}