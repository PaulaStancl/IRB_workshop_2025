{"title":"Functions and conditions","markdown":{"yaml":{"title":"Functions and conditions","author":[{"name":"dr.sc. Paula Štancl","affiliation":"Bioinformatics group, Faculty of Science"},{"name":"dr.sc. Andrea Gelemanović","affiliation":"MedILS, UNIST"}],"format":{"html":{"self-contained":true,"toc":true,"toc-depth":5,"code-fold":false,"fig-align":"center","df-print":"paged","code-summary":"Show code","code-line-numbers":false,"code-tools":true}},"execute":{"echo":true,"warning":false,"message":false,"collapse":true}},"headingText":"What are functions?","containsRefs":false,"markdown":"\n\n\nFunctions are **reusable blocks of code** designed to perform specific tasks. They can take inputs (called **arguments**), perform operations, and return results. Functions help you write cleaner, more efficient, and more modular code.\n\nYou can use built-in R functions like `mean()`, `sum()`, or `length()`, or you can create your **own custom functions** using the `function()` keyword.\n\n## Function skeleton\n\nIn R, you can define your own functions using the `function()` keyword.\\\nA function takes **input(s)**, performs some **operations**, and usually **returns a result** which **is automatically the last line** in the function.\n\n::: callout-tip\n## Basic function structure\n\n```{r}\nfunction_name <- function(argument1, argument2 = default_value) {\n  # Code block that does something with the arguments\n  \n  result <- ...  # Some calculation or value\n  return(result) # Optional: explicitly return the result\n}\n```\n:::\n\n### Task example:\n\nLet's look at a simple example of how to write and use a custom function in R.\n\n```{r}\nmy_function <- function(x) {\n  res <- x*2 - 4\n  return(res)\n}\n```\n\nLet's use the custom function:\n\n```{r}\n# Add two numbers\nmy_function(5)\n# Add two vectors\nmy_function(c(1, 2, 3))\n```\n\n### Task example: Defining a function for cell division\n\nA scientist has **48** stem cells. Each one divides into **2** daughter cells.\n\n-   How many cells will there be after division?\n-   How many full groups of **10 cells** can you make?\n-   How many cells will be left over?\n\nWe'll write a custom function that **simulates 1 round of cell division** to solve this:\n\n```{r}\n# Define a function that takes the number of starting cells and returns division results\ncell_division_summary <- function(initial_cells, \n                                  group_size = 10 # default setting of an argument\n                                  ) {\n  \n  # total number of cells after 1 division\n  total_cells <- initial_cells * 2\n  # how many groups of cells are after 1 division\n  full_groups <- total_cells %/% group_size\n  # how many are leftover\n  leftover_cells <- total_cells %% group_size\n  \n  # Return a list with results since we can only return one line as an result\n  list(\n    total_cells = total_cells,\n    full_groups = full_groups,\n    leftover_cells = leftover_cells\n  )\n}\n\n# Call the function with 48 cells\ncell_division_summary(48)\n```\n\n##### Task\n\nModify the `cell_division_summary` function so that it supports **multiple rounds of cell division**.\n\nEach cycle should double the total number of cells.\n\nYou should add an additional argument called `n_cycles`, which:\n\n-   represents the number of division cycles (default should be 1)\n\n-   adjusts the total number of cells to be: `initial_cells * 2^n_cycles`\n\n```{r}\n# Write the solution here\n```\n\n# Conditions\n\nConditions in R allow you to **make decisions** in your code. They are typically used with **`if`**, **`else if`**, and **`else`** statements.\n\nThese control structures let your code behave differently depending on whether certain **logical conditions** are `TRUE` or `FALSE`.\n\nFor example, you might want to check if a number is positive, negative, or zero, and respond differently in each case. Conditions are essential when building functions, loops, and any logic that depends on the data.\n\n::: callout-tip\n## Basic conditional structure\n\n**Simple `if` condition**\n\n```{r, eval=FALSE}\nif (condition) {\n  # Code to run if condition is TRUE\n}\n```\n\n**Advance multiple conditions**\n\n```{r, eval=FALSE}\nif (condition) {\n  # Code to run if condition is TRUE\n} else if (another_condition) { # else if as many times as needed in the conditions\n  # Code to run if the first condition is FALSE, but this one is TRUE\n} else {\n  # Code to run if none of the above conditions are TRUE\n}\n```\n:::\n\nExample of this structure\n\n```{r}\n# define a vector\nx <- -3\n\n# write a message\nif (x > 0) {\n  print(\"Positive number\")\n} else if (x == 0) {\n  print(\"Zero\")\n} else {\n  print(\"Negative number\")\n}\n```\n\nAnother example\n\n```{r}\n# Define a single age\nage <- 25\n\n# Use one if statement\nif (age < 30) {\n  my_age <- c(\"young\")\n} else {\n  my_age <- c(\"old\")\n}\n\n# write a sentance about my age\nprint(paste0(\"I feel very \", my_age, \"!\"))\n```\n\nThese tools allow you to build logic into your code so that it can react to different values or situations.\n\n::: callout-important\nUse `if`/`else` for single conditions, and `ifelse()` when working with vectors.\n:::\n\n::: callout-tip\n## Vectorized conditions with `ifelse()`\n\nThe `ifelse()` function is used to apply a condition across a **vector**. It checks each element and returns one value if the condition is `TRUE`, and another if it is `FALSE`.\n\n```{r}\n# Example vector of temperatures\ntemps <- c(18, 22, 30, 15)\n\n# Label each temperature as \"Warm\" or \"Cool\"\nifelse(temps >= 20, \"Warm\", \"Cool\")\n```\n:::\n\n### Summary of conditional statements\n\n| Syntax                | Description                                                | Example                          |\n|------------------|---------------------------------|--------------------|\n| `if (condition)`      | Executes code only if the condition is `TRUE`              | `if (x > 0) print(\"Positive\")`   |\n| `else`                | Executes code if the previous `if` was `FALSE`             | `else print(\"Not positive\")`     |\n| `else if (condition)` | Checks another condition if the first `if` fails           | `else if (x == 0) print(\"Zero\")` |\n| `ifelse(cond, a, b)`  | Vectorized `if`, returns `a` if `cond` is `TRUE`, else `b` | `ifelse(x > 0, \"Yes\", \"No\")`     |\n\n------------------------------------------------------------------------\n\n##### Task : Practice condition statments\n\nA bacterial culture is being observed. You are given the number of bacteria after 1 hour.\n\n-   If the number of bacteria is greater than 1000, print `\"Rapid growth\"`.\n-   If the number is between 500 and 1000 (inclusive), print `\"Moderate growth\"`.\n-   If the number is below 500, print `\"Slow growth\"`.\n\nWrite an `if`/`else if`/`else` statement to classify the growth.\n\n```{r, eval=FALSE}\n# Write the solution here\n# TODO: Define a vector containing any number of bacteria\nvec <- \n\n# TODO: Add your conditional statements and print the growth classification\n\n```\n\n##### Taks : Add growth classification to a `cell_division_summary` function\n\nYou are given a function that calculates the number of cells after one division and groups them based on a specified group size.\n\nYour task is to **modify the function** to also classify the **growth level** as a new element of the list called `growth_classification` based on the number of cells after division:\n\n-   If the number is **greater than 2000**, print `\"Extreme growth\"`\n-   If the number is **between 1001 and 2000**, print `\"Rapid growth\"`\n-   If the number is **between 501 and 1000**, print `\"Moderate growth\"`\n-   If the number is **500 or less**, print `\"Slow growth\"`\n\nThis classification should be added **using conditional statements** (`if`, `else if`, `else`) inside the function.\n\n```{r}\n# Write the solution here\ncell_division_summary <- function(initial_cells,\n                                  group_size = 10) {\n  \n  # Calculate total number of cells after 1 division\n  total_cells <- initial_cells * 2\n  \n  # TODO: Add your conditional statements here to define a variable called 'growth_classification'\n  \n  \n  # Calculate number of full groups\n  full_groups <- total_cells %/% group_size\n  \n  # Calculate number of leftover cells\n  leftover_cells <- total_cells %% group_size\n  \n  # TODO: return ALL values in a list\n  list(\n    total_cells = total_cells,\n    full_groups = full_groups,\n    leftover_cells = leftover_cells\n  )\n}\n\n# TODO: Run your function on some example\n```\n::: callout-important\n## Messages, Warnings, and Errors in functions\n\nWhen writing your own functions, it's useful to give feedback to the user using different types of messages:\n\n-   **`message()`** -- Informational messages. These are shown but do not interrupt execution.\n\n```{r, eval=FALSE}\nmessage(\"Calculation complete.\")\n```\n\n-   **`warning()`** -- Alerts the user that something may be wrong, but the function continues running.\n\n```{r, eval=FALSE}\nif (x < 0) warning(\"Negative value detected.\")\n```\n\n-   **`stop()`** -- Stops the function and throws an error. Use this to prevent further execution if input is invalid.\n\n```{r, eval=FALSE}\nif (!is.numeric(x)) stop(\"Input must be numeric.\")\n```\n:::\n\n#### Example in a function\n\n```{r}\nmy_function <- function(x) {\n  \n  # Show a message when the function starts\n  message(\"Starting calculation...\")\n  \n  # Stop the function if x is not numeric\n  if (!is.numeric(x)) {\n    stop(\"Input must be numeric.\")\n  }\n  \n  # Perform the calculation\n  res <- x * 2 - 4\n  \n  # Warn the user if the result is negative\n  if (res < 0) {\n    warning(\"The result is negative.\")\n  }\n  \n  return(res)\n}\n\n```\n\n# Apply family\n\nThe `apply` family of functions (`apply`, `lapply`, `sapply`, `tapply`, `mapply`, etc.) is used to perform operations on data structures without writing explicit loops.\n\n### Summary of the `apply` Family\n\n| Function   | Input Type         | Output Type     | Description                                 |\n|----------------|----------------|----------------|------------------------|\n| `apply()`  | matrix, data.frame | vector, array   | Apply a function over rows or columns       |\n| `lapply()` | list, vector       | list            | Apply a function to each element            |\n| `sapply()` | list, vector       | simplified list | Like `lapply()`, but returns vector/matrix  |\n| `tapply()` | vector + factor    | vector, array   | Apply a function to grouped subsets         |\n| `mapply()` | multiple vectors   | vector, list    | Apply a function in parallel over arguments |\n\n### Examples\n\n1.  `sapply()` -- Simplified apply (tries to return vector or matrix)\n\n```{r}\n(lst <- list(a = 1:5, b = 6:10))\n# Same as lapply(), but returns a simplified vector\nsapply(lst, mean)\n```\n\n2.  `lapply()` -- list apply\n\n```{r}\n# Get the mean of each list element\nlapply(lst, mean)\n```\n\n3.  `apply()` -- Apply over rows or columns of a matrix or data frame\n\n```{r}\n# Create a 3x3 matrix\n(mat <- matrix(1:9, nrow = 3) )\n\n# Calculate the mean of each column (2 = columns)\napply(mat, 2, mean)\n\n# Calculate the sum of each row (1 = rows)\napply(mat, 1, sum)\n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"collapse":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"center","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"self-contained":true,"toc-depth":5,"output-file":"Day1_IRB25_part2.html"},"language":{"code-summary":"Show code"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.335","editor":"visual","theme":"styles.scss","mainfont":"Nunito","page-layout":"full","title":"Functions and conditions","author":[{"name":"dr.sc. Paula Štancl","affiliation":"Bioinformatics group, Faculty of Science"},{"name":"dr.sc. Andrea Gelemanović","affiliation":"MedILS, UNIST"}]},"extensions":{"book":{"multiFile":true}}}}}