[
  {
    "objectID": "Day1_IRB25_part2.html",
    "href": "Day1_IRB25_part2.html",
    "title": "Functions and conditions",
    "section": "",
    "text": "Functions are reusable blocks of code designed to perform specific tasks. They can take inputs (called arguments), perform operations, and return results. Functions help you write cleaner, more efficient, and more modular code.\nYou can use built-in R functions like mean(), sum(), or length(), or you can create your own custom functions using the function() keyword.\n\n\nIn R, you can define your own functions using the function() keyword.\nA function takes input(s), performs some operations, and usually returns a result which is automatically the last line in the function.\n\n\n\n\n\n\nBasic function structure\n\n\n\n\nfunction_name <- function(argument1, argument2 = default_value) {\n  # Code block that does something with the arguments\n  \n  result <- ...  # Some calculation or value\n  return(result) # Optional: explicitly return the result\n}\n\n\n\n\n\nLet’s look at a simple example of how to write and use a custom function in R.\n\nmy_function <- function(x) {\n  res <- x*2 - 4\n  return(res)\n}\n\nLet’s use the custom function:\n\n# Add two numbers\nmy_function(5)\n\n[1] 6\n\n# Add two vectors\nmy_function(c(1, 2, 3))\n\n[1] -2  0  2\n\n\n\n\n\nA scientist has 48 stem cells. Each one divides into 2 daughter cells.\n\nHow many cells will there be after division?\nHow many full groups of 10 cells can you make?\nHow many cells will be left over?\n\nWe’ll write a custom function that simulates 1 round of cell division to solve this:\n\n# Define a function that takes the number of starting cells and returns division results\ncell_division_summary <- function(initial_cells, \n                                  group_size = 10 # default setting of an argument\n                                  ) {\n  \n  # total number of cells after 1 division\n  total_cells <- initial_cells * 2\n  # how many groups of cells are after 1 division\n  full_groups <- total_cells %/% group_size\n  # how many are leftover\n  leftover_cells <- total_cells %% group_size\n  \n  # Return a list with results since we can only return one line as an result\n  list(\n    total_cells = total_cells,\n    full_groups = full_groups,\n    leftover_cells = leftover_cells\n  )\n}\n\n# Call the function with 48 cells\ncell_division_summary(48)\n\n$total_cells\n[1] 96\n\n$full_groups\n[1] 9\n\n$leftover_cells\n[1] 6\n\n\n\n\nModify the cell_division_summary function so that it supports multiple rounds of cell division.\nEach cycle should double the total number of cells.\nYou should add an additional argument called n_cycles, which:\n\nrepresents the number of division cycles (default should be 1)\nadjusts the total number of cells to be: initial_cells * 2^n_cycles\n\n\n# Write the solution here"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Day1_IRB25_part1.html",
    "href": "Day1_IRB25_part1.html",
    "title": "Introduction to R",
    "section": "",
    "text": "Hello everyone to your first session “Introduction to R” in the Institute Ruder Boskovic (IRB) workshop. During this session, you will learn the basics to R programming and working environment."
  },
  {
    "objectID": "Day1_IRB25_part1.html#variable",
    "href": "Day1_IRB25_part1.html#variable",
    "title": "Introduction to R",
    "section": "Variable",
    "text": "Variable\n\nCreating a variable\nTo create a certain object, you need to give it a name followed by the assignment operator <- and the value you want to store it. To see the stored value in a variable, you can call it using parentheses or by typing the object name.\n\nvec <- 5\n# Print\nvec\n\n[1] 5\n\n# Print\n(vec2 <- 10)\n\n[1] 10\n\n\n\n\nNaming a variable\nWhen naming the variables, they mustn’t be too short or too long. Avoid meaningless variable names and name them logically ( example: mRNA_human ) R is case sensitive ( example: vec is different to Vec ). Some names cannot be used because they are the names of fundamental functions in R (e.g., if, else, for…). In general, even if it’s allowed, it’s best to not use other function names (e.g., c, t, mean, data, df). Furthermore, avoid using dots (.) within a variable name, such as in my.mRNA. A lot of functions in R have dots in their name for historical reasons and dots have special meaning in R so it is best to avoid them."
  },
  {
    "objectID": "Day1_IRB25_part1.html#vectors",
    "href": "Day1_IRB25_part1.html#vectors",
    "title": "Introduction to R",
    "section": "Vectors",
    "text": "Vectors\nA vector is the most common and basic data type in R. A vector is composed by a series of values. V ectors can be composed of integer/numeric, logical or character values. Using the c()function you can assign a series of values to a vector. The simplest way to create a sequence of numbers in R is by using the : operator.\nExamples of defining vectors\n\n( first_vec_num <- c(1,2,5) )\n\n[1] 1 2 5\n\n#The simplest way to create a sequence of numbers in R is by using the : operator. \n( second_vec_num <- 1:30 )\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30\n\n( first_vec_character <- c(\"human\", \"mouse\", \"dog\", \"cat\") )\n\n[1] \"human\" \"mouse\" \"dog\"   \"cat\"  \n\n( first_vec_logic <- c(TRUE, FALSE, TRUE) )\n\n[1]  TRUE FALSE  TRUE\n\n# create a vector containing different types\n( mix_vec <-c(1, \"sea\", TRUE) )\n\n[1] \"1\"    \"sea\"  \"TRUE\"\n\n\n\nDifferent types and classes\n\nTypes\n\ncharacter\ndouble (for double precision floating point numbers)\ninteger\n\n\n\n\n\n\n\nUseful functions for determining types\n\n\n\n\nclass()\nReturns the class of an object (e.g., \"numeric\", \"character\", \"data.frame\"), giving a general idea of its structure.\ntypeof()\nProvides the low-level internal storage type of an object (e.g., \"double\", \"integer\", \"list\"), which can be more specific than class().\nis.numeric(), is.character(), is.logical(), etc.\nReturn TRUE or FALSE depending on whether the object is of the specified type. These are useful for checking expected input types in functions.\nas.numeric(), as.character(), as.logical(), etc.\nCoerce (convert) an object to the specified type, if possible. These are helpful when transforming data types explicitly.\nstr()\nProvides a compact, readable summary of the structure of an R object, including its type, dimensions, and content preview.\n\n\n\nWhat are the types of our objects?\n\n# double/numeric\ntypeof(first_vec_num)\n\n[1] \"double\"\n\n# character\ntypeof(first_vec_character)\n\n[1] \"character\"\n\n# logical\ntypeof(first_vec_logic)\n\n[1] \"logical\"\n\n# character\ntypeof(mix_vec)\n\n[1] \"character\"\n\n\n\n\n\n\n\n\nConverting types from one to another\n\n\n\nNumerical can be converted to character,\n\n# To character\nfirst_vec_num\n\n[1] 1 2 5\n\nas.character(first_vec_num)\n\n[1] \"1\" \"2\" \"5\"\n\n\nwhile not all characters can be converted to numerical:\n\n# To numeric\nfirst_vec_character\n\n[1] \"human\" \"mouse\" \"dog\"   \"cat\"  \n\nas.numeric(first_vec_character)\n\nWarning: NAs introduced by coercion\n\n\n[1] NA NA NA NA\n\nas.numeric(mix_vec)\n\nWarning: NAs introduced by coercion\n\n\n[1]  1 NA NA\n\n\n\n\n\n\nCalculation with vectors\nR performs element-wise operations on vectors by default.\nExample: c(1, 2, 3) + c(10, 20, 30) returns 11 22 33\n\nc(1, 2, 3) + c(10, 20, 30)\n\n[1] 11 22 33\n\n\n\n\n\n\n\n\nVectorization\n\n\n\n\nVectorization means operations are applied to all elements at once, without loops.\n\nIt’s efficient and concise.\n\nArithmetic operators (+, -, *, /, ^) are vectorized.\n\nExample: c(2, 4, 6) * 2 returns 4 8 12\n\nFunctions like log(), sqrt(), exp() are also vectorized.\n\nExample: sqrt(c(4, 9, 16)) returns 2 3 4\n\nWhen vectors are of different lengths, R recycles the shorter one (with a warning if not a multiple).\n\nExample: c(1, 2, 3) + 1 returns 2 3 4\n\n\n\nTask\nLet’s go back and see what our variables are holding:\n\n# short vector\nvec\n\n[1] 5\n\n# first vector\nfirst_vec_num\n\n[1] 1 2 5\n\n#second vector\nsecond_vec_num\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30\n\n\nWhat will be the outcome of these operations? Explain it with comment in the following code chunk!\n\nfirst_vec_num + vec \n\nfirst_vec_num + second_vec_num\n\nfirst_vec_num * second_vec_num\n\n\n\n\n\nSubsetting vectors\nSubsetting is a way to access specific elements of a vector using indexing.\nTo extract one or more values, provide the corresponding indices inside square brackets ([]).\n\n\n\n\n\n\nExamples\n\n\n\n\nSelecting the second element\n\n\nfirst_vec_num[2]\n\n[1] 2\n\n\n\nNegative subsetting- meaning not selecting the second element\n\n\nfirst_vec_num[-2]\n\n[1] 1 5\n\n\n\nSelecting first and third elements\n\n\nfirst_vec_num[c(1,3)]\n\n[1] 1 5\n\n\n\n\nMoreover, selection can be done using other vectors, such as logical and numeric.\n\nTask\nWhat happened when you used a logical vector for subsetting?\n\nfirst_vec_num[first_vec_logic]\n\nfirst_vec_num[first_vec_num]\n\n\n\nAdding and replacing elements\nIn R, you can modify vectors by adding new elements or replacing existing ones using indexing.\n\nTo add elements, simply use the c() function to concatenate new values to the existing vector.\nTo replace elements, use square bracket indexing and assign a new value to a specific position.\n\n\n# Add new values to the end of the vector\nsecond_vec_num <- c(second_vec_num, 1, 30, 30, 30, 1, 1)\nsecond_vec_num\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30  1 30 30 30  1  1\n\n# Replace the first element with a new value\nsecond_vec_num[1] <- 10000\nsecond_vec_num\n\n [1] 10000     2     3     4     5     6     7     8     9    10    11    12\n[13]    13    14    15    16    17    18    19    20    21    22    23    24\n[25]    25    26    27    28    29    30     1    30    30    30     1     1\n\n\n\n\nBoolean Operators\nBoolean operators in R (and other programming languages) are used to perform logical comparisons. They return TRUE or FALSE values based on whether a condition is met.\n\n\n\nOperator\nDescription\nExample\nResult\n\n\n\n\n>\nGreater than\n5 > 6\nFALSE\n\n\n<\nLess than\n5 < 6\nTRUE\n\n\n==\nEquals to\n10 == 10\nTRUE\n\n\n!=\nNot equal to\n10 != 10\nFALSE\n\n\n>=\nGreater than or equal to\n5 >= 6\nFALSE\n\n\n<=\nLess than or equal to\n6 <= 6\nTRUE\n\n\n\n\n\n\n\n\n\nExamples\n\n\n\n\nBasic inequality: Is 2 not equal to 2?\n\n\n2 != 2\n\n[1] FALSE\n\n\n\nCompare a numeric vector to a single number (element-wise comparison)\n\n\nfirst_vec_num == 2\n\n[1] FALSE  TRUE FALSE\n\n\n\nCompare two vectors of unequal length\n\n\nfirst_vec_num == first_vec_character\n\nWarning in first_vec_num == first_vec_character: longer object length is not a\nmultiple of shorter object length\n\n\n[1] FALSE FALSE FALSE FALSE\n\n\n\n\n\nTask\nIn the second example, we got a warning message longer object length is not a multiple of shorter object length and an output FALSE FALSE FALSE FALSE. What happened here?\n\n# Write your answer here\n\n\n\n\n\nBoolean with logical operators\n\n\n\n\n\n\nThere are three types of logical operators in R\n\n\n\nAND operator &\nOR operator |\nNOT operator !\n\n\nExplain the examples below:\n\nfirst_vec_num[first_vec_num == 5 & first_vec_num == 2]\n\nnumeric(0)\n\nfirst_vec_num[first_vec_num == 5 | first_vec_num == 2]\n\n[1] 2 5\n\n\n\n\nExamples of useful function\n\n\n\n\n\n\nBasic descriptive statistics\n\n\n\n\nsummary()\nProvides a quick overview of an object. For numeric vectors or data frames, it returns the minimum, 1st quartile, median, mean, 3rd quartile, and maximum.\nmean()\nCalculates the arithmetic average of a numeric vector.\nsum()\nAdds all elements of a numeric vector together.\nsd()\nComputes the standard deviation, which measures the amount of variation or dispersion in the data.\ntable()\nCreates a frequency table showing how often each value appears in a vector or factor.\n\n\n\nExample\n\nsum(c(10,10))\n\n[1] 20\n\n# Summary statistics\nsum(second_vec_num)\n\n[1] 10557\n\nsummary(second_vec_num)\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n    1.00     7.75    16.50   293.25    25.25 10000.00 \n\n# Count table\ntable( second_vec_num )\n\nsecond_vec_num\n    1     2     3     4     5     6     7     8     9    10    11    12    13 \n    3     1     1     1     1     1     1     1     1     1     1     1     1 \n   14    15    16    17    18    19    20    21    22    23    24    25    26 \n    1     1     1     1     1     1     1     1     1     1     1     1     1 \n   27    28    29    30 10000 \n    1     1     1     4     1 \n\n\n\n\n\n\n\n\nVector inspection\n\n\n\n\nlength()\nReturns the number of elements in a vector.\nunique()\nExtracts the distinct (non-duplicate) values from a vector.\nanyNA()\nChecks if there are any missing (NA) values in a vector and returns TRUE or FALSE.\nis.na()\nReturns a logical vector indicating which elements are NA.\nsort()\nArranges the elements of a vector in ascending (default) or descending order.\n\n\n\n\n# Number of elements in vector\nlength(second_vec_num)\n\n[1] 36\n\n# Order a vector\nsort_second_vec <- sort(second_vec_num, \n                          decreasing = FALSE)\nsecond_vec_num; sort_second_vec\n\n [1] 10000     2     3     4     5     6     7     8     9    10    11    12\n[13]    13    14    15    16    17    18    19    20    21    22    23    24\n[25]    25    26    27    28    29    30     1    30    30    30     1     1\n\n\n [1]     1     1     1     2     3     4     5     6     7     8     9    10\n[13]    11    12    13    14    15    16    17    18    19    20    21    22\n[25]    23    24    25    26    27    28    29    30    30    30    30 10000\n\n# Count table\nsort( second_vec_num )\n\n [1]     1     1     1     2     3     4     5     6     7     8     9    10\n[13]    11    12    13    14    15    16    17    18    19    20    21    22\n[25]    23    24    25    26    27    28    29    30    30    30    30 10000\n\n# is there NA\nis.na( second_vec_num ) \n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\nanyNA( second_vec_num )\n\n[1] FALSE\n\n\n\nTask\nWhat is the mean of every second element in the vector second_vec_num?\nHard mode: Solve it in two different ways?\n\n# Write the solution here"
  },
  {
    "objectID": "Day1_IRB25_part1.html#matrix",
    "href": "Day1_IRB25_part1.html#matrix",
    "title": "Introduction to R",
    "section": "Matrix",
    "text": "Matrix\nMatrix is a two dimensional data structure in R programming. It is similar to vector but additionally contains the dimension attribute.\n\n\n\n\n\n\nDefining a matrix\n\n\n\nYou define a matrix using the matrix function which takes data as vector, number of columns and/or rows to create a matrix. Argument byrow when FALSE is filling the matrix by columns\n\n# filling by rows\nfirst_mat <- matrix(1:20, nrow=5)\nfirst_mat\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n\n# filling by columns\nsecond_mat <- matrix(1:20, nrow=5,\n                        byrow=TRUE)\nsecond_mat\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n[5,]   17   18   19   20\n\n\n\n\n\nSubsetting a matrix\nSince matrices are two dimensional, you have to subset in both dimensions. Subsetting is done by opening square brackets with supplied index for each dimension separated by a comma. Blank subsetting is useful because you keep all rows or all columns.\n\nfirst_mat\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n\nfirst_mat[1, 3:4]\n\n[1] 11 16\n\nfirst_mat[1:2, 3:4]\n\n     [,1] [,2]\n[1,]   11   16\n[2,]   12   17\n\n\n\n\nReplacing elements in a matrix\nYou can replace individual elements in a matrix using indexing. Here’s an example:\n\n# Access the element in the first row, first column\nfirst_mat[1,1]\n\n[1] 1\n\n# Replace that element with the character \"a\"\nfirst_mat[1,1] <- \"a\"\n# View the matrix\nfirst_mat\n\n     [,1] [,2] [,3] [,4]\n[1,] \"a\"  \"6\"  \"11\" \"16\"\n[2,] \"2\"  \"7\"  \"12\" \"17\"\n[3,] \"3\"  \"8\"  \"13\" \"18\"\n[4,] \"4\"  \"9\"  \"14\" \"19\"\n[5,] \"5\"  \"10\" \"15\" \"20\"\n\n\n\n\n\n\n\n\nUseful functions for matrices\n\n\n\n\ndim() – Returns or sets the dimensions of a matrix (rows, columns).\nnrow(), ncol() – Get the number of rows or columns.\nt() – Transposes the matrix (swaps rows and columns).\nrowSums(), colSums() – Calculate row-wise or column-wise sums.\nrowMeans(), colMeans() – Calculate means for each row or column.\n\n\n\n\nTask\n\nCreate a matrix called second_matrix using the vector second_vec_num.\nFill the matrix by columns.\nDetermine the dimensions of the matrix.\nCalculate the sum of each row.\nCalculate the sum of each column.\n\n\n# Write the solution here"
  },
  {
    "objectID": "Day1_IRB25_part1.html#list",
    "href": "Day1_IRB25_part1.html#list",
    "title": "Introduction to R",
    "section": "List",
    "text": "List\nList is an object containing elements of various types – like strings, numbers, matrices, vectors, functions and another list inside it. The list is created using the list() function in R.\n\nfirst_list <- list(first = c(7,5,24,88),\n                   second = c(\"abc\", 3))\n\nfirst_list\n\n$first\n[1]  7  5 24 88\n\n$second\n[1] \"abc\" \"3\"  \n\n\n\nAccessing elements of a list\nYou can access elements of a list in several ways depending on whether you want:\n\nthe actual value inside the list, or\na sublist containing the element.\n\n\n\n\n\n\n\nDifferent subseting results in different object\n\n\n\n\nIf elements have names, you can access them with $. Here we have names the first stored element as first “first” and therefore we can call it.\n\n\nfirst_list$first\n\n[1]  7  5 24 88\n\n\n\nUsing single brackets [], we get a list\n\n\nfirst_list[1]\n\n$first\n[1]  7  5 24 88\n\n\n\nUsing double brackets [[]], we get a stored element\n\n\nfirst_list[[1]]\n\n[1]  7  5 24 88\n\n\n\nUsing double brackets [[ ]], we access the actual stored element, and then we can subset it further if it’s a vector.\n\n\nfirst_list[[1]][2]\n\n[1] 5\n\n\n\n\n\n\nReplacing and adding elements\nYou can both replace and add values within elements of a list using double brackets [[ ]] and indexing.\n\n# Replace the first value in the first element of the list\nfirst_list[[1]][1] <- \"A\"\n\nAdd a new value to a list element\n\n# Add a new (5th) value to the first element of the list\nfirst_list[[1]][5] <- \"x\" \n\nView the result\n\nfirst_list\n\n$first\n[1] \"A\"  \"5\"  \"24\" \"88\" \"x\" \n\n$second\n[1] \"abc\" \"3\"  \n\n\n\n\nList to vector\nIf you want to convert a list into a single atomic vector, you can use the unlist() function.\nThis flattens all elements of the list into a single vector, as long as the contents are compatible (e.g., numeric and character can both be coerced into character).\n\nunlist(first_list)\n\n first1  first2  first3  first4  first5 second1 second2 \n    \"A\"     \"5\"    \"24\"    \"88\"     \"x\"   \"abc\"     \"3\" \n\nfirst_list\n\n$first\n[1] \"A\"  \"5\"  \"24\" \"88\" \"x\" \n\n$second\n[1] \"abc\" \"3\"  \n\n\n\nTaks\nThe names created when unlisting a list are automatically generated by R and reflect the structure of the original list.\n\nFirst, save the result of unlist into a new vector called unlist_first.\nThen, use the function unname.\nWhat does this do?\n\n\n# Write the solution here"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "IRB workshop 2025",
    "section": "",
    "text": "👋 Welcome to the IRB Workshop 2025 Website\nThis website hosts the material for the IRB Workshop 2025. You’ll find R code examples, tasks, and explanations for each session."
  },
  {
    "objectID": "Day1_IRB25_part2.html#load-the-packages",
    "href": "Day1_IRB25_part2.html#load-the-packages",
    "title": "R packages and advance table manipulation",
    "section": "Load the packages",
    "text": "Load the packages\nWhen you install a package in R (using install.packages() or similar), you’re downloading it and saving it to your computer. This only needs to be done once (per R environment).\nHowever, to use the functions or data from a package in your current R session, you must load the package with library() or require().\n\nlibrary(\"magrittr\")\nlibrary(\"data.table\")\nlibrary(\"ggpubr\")\nlibrary(\"airway\")"
  },
  {
    "objectID": "Day1_IRB25_part2.html#pipes",
    "href": "Day1_IRB25_part2.html#pipes",
    "title": "R packages and advance table manipulation",
    "section": "Pipes ( %>% )",
    "text": "Pipes ( %>% )\nPackage magrittr provides a new “pipe”-like operator, %>%. The pipe operator allows you to pipe a value forward into a function. For example you can write vec %>% sum instead of sum(vec) . It makes your code more intuitive to read and write especially when “pipping/chaining” multiple arguments. Fill in the example below:\n\nsample(x = 1:1000, size = 40) %>% \n   # Call function sum on the whole vector\n\n   # Select only minimal and maximum  value"
  },
  {
    "objectID": "Day1_IRB25_part1.html#functions-and-useful-tricks",
    "href": "Day1_IRB25_part1.html#functions-and-useful-tricks",
    "title": "Introduction to R",
    "section": "Functions and useful tricks",
    "text": "Functions and useful tricks\nFunctions are “conserved scripts” that automate more complicated sets of commands including operations assignments, etc. Many functions are predefined, or can be made available by importing R packages (more on that later). A function usually gets one or more inputs called arguments. Functions often (but not always) return a value. Adding ? in front of any function opens a help, description and usage of the function. A typical example function is typeof.\n\n\n\n\n\n\nHelp with functions\n\n\n\nWhat does the function type do?\n(Hint: ?typeof)\n\n\n\n?typeof"
  },
  {
    "objectID": "Day1_IRB25_part2_functions.html",
    "href": "Day1_IRB25_part2_functions.html",
    "title": "Functions and conditions",
    "section": "",
    "text": "What are functions?\n\n\nConditions"
  },
  {
    "objectID": "Day2_IRB25_part1.html",
    "href": "Day2_IRB25_part1.html",
    "title": "R packages and advance table manipulation",
    "section": "",
    "text": "CRAN is the official repository for R packages. It hosts thousands of stable, peer-reviewed R packages that have passed strict checks for quality and compatibility.\n\n#Install from CRAN as follow:\ninstall.packages(\"magrittr\")\ninstall.packages(\"dplyr\")\ninstall.packages(\"ggplot2\") \n\n\n\n\nGitHub is a platform for code sharing and collaboration, widely used by developers. Many R package authors share their development versions on GitHub—these might include the newest features or bug fixes that haven’t yet been submitted to CRAN.\n\n#Or, install the latest version from GitHub as follow:\n# Install\nif(!require(devtools)) install.packages(\"devtools\")\ndevtools::install_github(\"kassambara/ggpubr\")\n\n\n\n\nBioconductor is a specialized repository for packages focused on bioinformatics, genomics, and computational biology. It includes tools for analyzing DNA/RNA sequencing, gene expression, and other biological data.\n\n## Bioconductor\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\n\nBiocManager::install(\"airway\")"
  },
  {
    "objectID": "Day2_IRB25_part1.html#load-the-packages",
    "href": "Day2_IRB25_part1.html#load-the-packages",
    "title": "R packages and advance table manipulation",
    "section": "Load the packages",
    "text": "Load the packages\nWhen you install a package in R (using install.packages() or similar), you’re downloading it and saving it to your computer. This only needs to be done once (per R environment).\nHowever, to use the functions or data from a package in your current R session, you must load the package with library() or require().\n\nlibrary(\"magrittr\")\nlibrary(\"data.table\")\nlibrary(\"ggpubr\")\nlibrary(\"airway\")"
  },
  {
    "objectID": "Day2_IRB25_part1.html#pipes",
    "href": "Day2_IRB25_part1.html#pipes",
    "title": "R packages and advance table manipulation",
    "section": "Pipes ( %>% )",
    "text": "Pipes ( %>% )\nPackage magrittr provides a new “pipe”-like operator, %>%. The pipe operator allows you to pipe a value forward into a function. For example you can write vec %>% sum instead of sum(vec) . It makes your code more intuitive to read and write especially when “pipping/chaining” multiple arguments. Fill in the example below:\n\nsample(x = 1:1000, size = 40) %>% \n   # Call function sum on the whole vector\n\n   # Select only minimal and maximum  value"
  },
  {
    "objectID": "Day1_IRB25_part3.html",
    "href": "Day1_IRB25_part3.html",
    "title": "Basic regular expressions",
    "section": "",
    "text": "Regular expressions (regex) are compact patterns used to search, match, and manipulate text in a flexible way.\nA regex is simply a string made up of special characters that define a text pattern."
  },
  {
    "objectID": "Day1_IRB25_part3.html#what-are-regular-expressions",
    "href": "Day1_IRB25_part3.html#what-are-regular-expressions",
    "title": "Short introduction to regular expressions",
    "section": "What are Regular Expressions?",
    "text": "What are Regular Expressions?\nRegular expressions (regex) are compact patterns used to search, match, and manipulate text in a flexible way.\nA regex is simply a string made up of special characters that define a text pattern."
  },
  {
    "objectID": "Day1_IRB25_part3.html#what-can-regex-represent",
    "href": "Day1_IRB25_part3.html#what-can-regex-represent",
    "title": "Basic regular expressions",
    "section": "What can regex represent?",
    "text": "What can regex represent?\nRegex patterns can describe:\n\nWildcards — match any single character using .\n\nQuantifiers — specify how many times a character or group appears (*, +, {n})\n\nGrouping — combine parts of patterns using parentheses ( )\n\nBoolean OR — match one pattern or another using |\n\nAnchors — specify where in the string to match (^ = start, $ = end)\n\nCharacter Sets — match specific characters using square brackets [abc]"
  },
  {
    "objectID": "Day1_IRB25_part3.html#example-in-r",
    "href": "Day1_IRB25_part3.html#example-in-r",
    "title": "Short introduction to regular expressions",
    "section": "Example in R",
    "text": "Example in R\n\n# Match words that start with \"c\" and end with \"t\"\nwords <- c(\"cat\", \"coat\", \"cut\", \"bat\")\ngrep(\"^c.*t$\", words, value = TRUE)\n\n[1] \"cat\"  \"coat\" \"cut\""
  },
  {
    "objectID": "Day1_IRB25_part3.html#grep-pattern-matching-with-regex-in-r",
    "href": "Day1_IRB25_part3.html#grep-pattern-matching-with-regex-in-r",
    "title": "Basic regular expressions",
    "section": "grep() – Pattern matching with regex in R",
    "text": "grep() – Pattern matching with regex in R\nThe grep() function is one of the most common ways to use regular expressions in base R.\ng/re/p stands for:\nGlobal search for Regular Expression and Print matching lines\n\n\n\n\n\n\nBasic grep syntax\n\n\n\n\ngrep(\"pattern\", your_vector)\n\n\nBy default, it returns the positions of matching elements.\nTo return the matching values, use: value = TRUE\nTo return the indices or values that do not match, use: invert = TRUE\n\n\n\n\n\n\n\n\n\nExample how to use grep\nLet’s define a new character vector with a mix of names, codes, and text snippets:\n\nmy_strings <- c(\n  \"apple123\", \"banana\", \"cat!\", \"dog99\", \"zebra_2\", \n  \"Xray\", \"alpha-beta\", \"beta.alpha\", \"code42\", \"hello world!\",\n  \"abAB12\", \"123abc\", \"abc!\", \"end.\", \"Begin!\", \"test_case?\",\n  \"no_numbers\", \"DATA2025\", \"regex_fun\", \"start_end\"\n)\n\nFind strings that contain numbers\n\ngrep(\"\\\\d\", my_strings, value = TRUE)\n\n[1] \"apple123\" \"dog99\"    \"zebra_2\"  \"code42\"   \"abAB12\"   \"123abc\"   \"DATA2025\"\n\n\nFind strings that contain underscores\n\ngrep(\"_\", my_strings, value = TRUE)\n\n[1] \"zebra_2\"    \"test_case?\" \"no_numbers\" \"regex_fun\"  \"start_end\" \n\n\nFind strings that start with a lowercase letter\n\ngrep(\"^[a-z]\", my_strings, value = TRUE)\n\n [1] \"apple123\"     \"banana\"       \"cat!\"         \"dog99\"        \"zebra_2\"     \n [6] \"alpha-beta\"   \"beta.alpha\"   \"code42\"       \"hello world!\" \"abAB12\"      \n[11] \"abc!\"         \"end.\"         \"test_case?\"   \"no_numbers\"   \"regex_fun\"   \n[16] \"start_end\"   \n\n\n\nHow to find special characters?\nSometimes you want to match characters that are “special” in regex, like ., *, ?, (, ), etc.\nTo do this, you must escape them using a double backslash (\\\\) in R.\nLet’s say we want to find strings that contain a question mark:\n\ngrep(\"\\\\?\", my_strings, value = TRUE)\n\n[1] \"test_case?\"\n\n\n\nTasks\n\nFind strings that end with number\n\n\n# Write the solution here\n\n\nFind strings that do not start with capital letters\n\n\n# Write the solution here"
  }
]